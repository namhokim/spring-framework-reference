<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>24.&nbsp;JMS (Java Message Service)</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="스프링 프레임워크 레퍼런스 문서"><link rel="up" href="spring-integration.html" title="Part&nbsp;VI.&nbsp;Integration"><link rel="prev" href="ejb.html" title="23.&nbsp;Enterprise JavaBeans (EJB) integration"><link rel="next" href="jmx.html" title="25.&nbsp;JMX"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">24.&nbsp;JMS (Java Message Service)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ejb.html">이전</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;VI.&nbsp;Integration</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="jmx.html">다음</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="jms" href="#jms"></a>24.&nbsp;JMS (Java Message Service)</h2></div></div></div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-introduction" href="#jms-introduction"></a>24.1&nbsp;Introduction</h2></div></div></div>
<p>Spring provides a JMS integration framework that simplifies the use of the JMS API much
like Spring&#8217;s integration does for the JDBC API.</p>
<p>JMS can be roughly divided into two areas of functionality, namely the production and
consumption of messages. The <code class="literal">JmsTemplate</code> class is used for message production and
synchronous message reception. For asynchronous reception similar to Java EE&#8217;s
message-driven bean style, Spring provides a number of message listener containers that
are used to create Message-Driven POJOs (MDPs). Spring also provides a declarative way
of creating message listeners.</p>
<p>The package <code class="literal">org.springframework.jms.core</code> provides the core functionality for using
JMS. It contains JMS template classes that simplify the use of the JMS by handling the
creation and release of resources, much like the <code class="literal">JdbcTemplate</code> does for JDBC. The
design principle common to Spring template classes is to provide helper methods to
perform common operations and for more sophisticated usage, delegate the essence of the
processing task to user implemented callback interfaces. The JMS template follows the
same design. The classes offer various convenience methods for the sending of messages,
consuming a message synchronously, and exposing the JMS session and message producer to
the user.</p>
<p>The package <code class="literal">org.springframework.jms.support</code> provides <code class="literal">JMSException</code> translation
functionality. The translation converts the checked <code class="literal">JMSException</code> hierarchy to a
mirrored hierarchy of unchecked exceptions. If there are any provider specific
subclasses of the checked <code class="literal">javax.jms.JMSException</code>, this exception is wrapped in the
unchecked <code class="literal">UncategorizedJmsException</code>.</p>
<p>The package <code class="literal">org.springframework.jms.support.converter</code> provides a <code class="literal">MessageConverter</code>
abstraction to convert between Java objects and JMS messages.</p>
<p>The package <code class="literal">org.springframework.jms.support.destination</code> provides various strategies
for managing JMS destinations, such as providing a service locator for destinations
stored in JNDI.</p>
<p>The package <code class="literal">org.springframework.jms.annotation</code> provides the necessary infrastructure
to support annotation-driven listener endpoints using <code class="literal">@JmsListener</code>.</p>
<p>The package <code class="literal">org.springframework.jms.config</code> provides the parser implementation for the
<code class="literal">jms</code> namespace as well the java config support to configure listener containers and
create listener endpoints.</p>
<p>Finally, the package <code class="literal">org.springframework.jms.connection</code> provides an implementation of
the <code class="literal">ConnectionFactory</code> suitable for use in standalone applications. It also contains an
implementation of Spring&#8217;s <code class="literal">PlatformTransactionManager</code> for JMS (the cunningly named
<code class="literal">JmsTransactionManager</code>). This allows for seamless integration of JMS as a transactional
resource into Spring&#8217;s transaction management mechanisms.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-using" href="#jms-using"></a>24.2&nbsp;Using Spring JMS</h2></div></div></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-jmstemplate" href="#jms-jmstemplate"></a>24.2.1&nbsp;JmsTemplate</h3></div></div></div>
<p>The <code class="literal">JmsTemplate</code> class is the central class in the JMS core package. It simplifies the
use of JMS since it handles the creation and release of resources when sending or
synchronously receiving messages.</p>
<p>Code that uses the <code class="literal">JmsTemplate</code> only needs to implement callback interfaces giving them
a clearly defined high level contract. The <code class="literal">MessageCreator</code> callback interface creates a
message given a <code class="literal">Session</code> provided by the calling code in <code class="literal">JmsTemplate</code>. In order to
allow for more complex usage of the JMS API, the callback <code class="literal">SessionCallback</code> provides the
user with the JMS session and the callback <code class="literal">ProducerCallback</code> exposes a <code class="literal">Session</code> and
<code class="literal">MessageProducer</code> pair.</p>
<p>The JMS API exposes two types of send methods, one that takes delivery mode, priority,
and time-to-live as Quality of Service (QOS) parameters and one that takes no QOS
parameters which uses default values. Since there are many send methods in
<code class="literal">JmsTemplate</code>, the setting of the QOS parameters have been exposed as bean properties to
avoid duplication in the number of send methods. Similarly, the timeout value for
synchronous receive calls is set using the property <code class="literal">setReceiveTimeout</code>.</p>
<p>Some JMS providers allow the setting of default QOS values administratively through the
configuration of the <code class="literal">ConnectionFactory</code>. This has the effect that a call to
<code class="literal">MessageProducer</code>'s send method <code class="literal">send(Destination destination, Message message)</code> will
use different QOS default values than those specified in the JMS specification. In order
to provide consistent management of QOS values, the <code class="literal">JmsTemplate</code> must therefore be
specifically enabled to use its own QOS values by setting the boolean property
<code class="literal">isExplicitQosEnabled</code> to <code class="literal">true</code>.</p>
<p>For convenience, <code class="literal">JmsTemplate</code> also exposes a basic request-reply operation that allows
to send a message and wait for a reply on a temporary queue that is created as part of
the operation.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Instances of the <code class="literal">JmsTemplate</code> class are <span class="emphasis"><em>thread-safe once configured</em></span>. This is
important because it means that you can configure a single instance of a <code class="literal">JmsTemplate</code>
and then safely inject this <span class="emphasis"><em>shared</em></span> reference into multiple collaborators. To be
clear, the <code class="literal">JmsTemplate</code> is stateful, in that it maintains a reference to a
<code class="literal">ConnectionFactory</code>, but this state is <span class="emphasis"><em>not</em></span> conversational state.</p>
</td></tr></table></div>
<p>As of Spring Framework 4.1, <code class="literal">JmsMessagingTemplate</code> is built on top of <code class="literal">JmsTemplate</code>
and provides an integration with the messaging abstraction, i.e.
<code class="literal">org.springframework.messaging.Message</code>. This allows you to create the message to
send in generic manner.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-connections" href="#jms-connections"></a>24.2.2&nbsp;Connections</h3></div></div></div>
<p>The <code class="literal">JmsTemplate</code> requires a reference to a <code class="literal">ConnectionFactory</code>. The <code class="literal">ConnectionFactory</code>
is part of the JMS specification and serves as the entry point for working with JMS. It
is used by the client application as a factory to create connections with the JMS
provider and encapsulates various configuration parameters, many of which are vendor
specific such as SSL configuration options.</p>
<p>When using JMS inside an EJB, the vendor provides implementations of the JMS interfaces
so that they can participate in declarative transaction management and perform pooling
of connections and sessions. In order to use this implementation, Java EE containers
typically require that you declare a JMS connection factory as a <code class="literal">resource-ref</code> inside
the EJB or servlet deployment descriptors. To ensure the use of these features with the
<code class="literal">JmsTemplate</code> inside an EJB, the client application should ensure that it references the
managed implementation of the <code class="literal">ConnectionFactory</code>.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jms-caching-resources" href="#jms-caching-resources"></a>Caching Messaging Resources</h4></div></div></div>
<p>The standard API involves creating many intermediate objects. To send a message the
following <span class="emphasis"><em>API</em></span> walk is performed</p>
<pre class="literallayout">ConnectionFactory-&gt;Connection-&gt;Session-&gt;MessageProducer-&gt;send</pre>
<p>Between the ConnectionFactory and the Send operation there are three intermediate
objects that are created and destroyed. To optimise the resource usage and increase
performance two implementations of <code class="literal">ConnectionFactory</code> are provided.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jms-connection-factory" href="#jms-connection-factory"></a>SingleConnectionFactory</h4></div></div></div>
<p>Spring provides an implementation of the <code class="literal">ConnectionFactory</code> interface,
<code class="literal">SingleConnectionFactory</code>, that will return the same <code class="literal">Connection</code> on all
<code class="literal">createConnection()</code> calls and ignore calls to <code class="literal">close()</code>. This is useful for testing and
standalone environments so that the same connection can be used for multiple
<code class="literal">JmsTemplate</code> calls that may span any number of transactions. <code class="literal">SingleConnectionFactory</code>
takes a reference to a standard <code class="literal">ConnectionFactory</code> that would typically come from JNDI.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jdbc-connection-factory-caching" href="#jdbc-connection-factory-caching"></a>CachingConnectionFactory</h4></div></div></div>
<p>The <code class="literal">CachingConnectionFactory</code> extends the functionality of <code class="literal">SingleConnectionFactory</code>
and adds the caching of Sessions, MessageProducers, and MessageConsumers. The initial
cache size is set to 1, use the property <code class="literal">SessionCacheSize</code> to increase the number of
cached sessions. Note that the number of actual cached sessions will be more than that
number as sessions are cached based on their acknowledgment mode, so there can be up to
4 cached session instances when <code class="literal">SessionCacheSize</code> is set to one, one for each
<code class="literal">AcknowledgementMode</code>. MessageProducers and MessageConsumers are cached within their
owning session and also take into account the unique properties of the producers and
consumers when caching. MessageProducers are cached based on their destination.
MessageConsumers are cached based on a key composed of the destination, selector,
noLocal delivery flag, and the durable subscription name (if creating durable consumers).</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-destinations" href="#jms-destinations"></a>24.2.3&nbsp;Destination Management</h3></div></div></div>
<p>Destinations, like ConnectionFactories, are JMS administered objects that can be stored
and retrieved in JNDI. When configuring a Spring application context you can use the
JNDI factory class <code class="literal">JndiObjectFactoryBean</code> / <code class="literal">&lt;jee:jndi-lookup&gt;</code> to perform dependency
injection on your object&#8217;s references to JMS destinations. However, often this strategy
is cumbersome if there are a large number of destinations in the application or if there
are advanced destination management features unique to the JMS provider. Examples of
such advanced destination management would be the creation of dynamic destinations or
support for a hierarchical namespace of destinations. The <code class="literal">JmsTemplate</code> delegates the
resolution of a destination name to a JMS destination object to an implementation of the
interface <code class="literal">DestinationResolver</code>. <code class="literal">DynamicDestinationResolver</code> is the default
implementation used by <code class="literal">JmsTemplate</code> and accommodates resolving dynamic destinations. A
<code class="literal">JndiDestinationResolver</code> is also provided that acts as a service locator for
destinations contained in JNDI and optionally falls back to the behavior contained in
<code class="literal">DynamicDestinationResolver</code>.</p>
<p>Quite often the destinations used in a JMS application are only known at runtime and
therefore cannot be administratively created when the application is deployed. This is
often because there is shared application logic between interacting system components
that create destinations at runtime according to a well-known naming convention. Even
though the creation of dynamic destinations is not part of the JMS specification, most
vendors have provided this functionality. Dynamic destinations are created with a name
defined by the user which differentiates them from temporary destinations and are often
not registered in JNDI. The API used to create dynamic destinations varies from provider
to provider since the properties associated with the destination are vendor specific.
However, a simple implementation choice that is sometimes made by vendors is to
disregard the warnings in the JMS specification and to use the <code class="literal">TopicSession</code> method
<code class="literal">createTopic(String topicName)</code> or the <code class="literal">QueueSession</code> method <code class="literal">createQueue(String
queueName)</code> to create a new destination with default destination properties. Depending
on the vendor implementation, <code class="literal">DynamicDestinationResolver</code> may then also create a
physical destination instead of only resolving one.</p>
<p>The boolean property <code class="literal">pubSubDomain</code> is used to configure the <code class="literal">JmsTemplate</code> with
knowledge of what JMS domain is being used. By default the value of this property is
false, indicating that the point-to-point domain, Queues, will be used. This property
used by <code class="literal">JmsTemplate</code> determines the behavior of dynamic destination resolution via
implementations of the <code class="literal">DestinationResolver</code> interface.</p>
<p>You can also configure the <code class="literal">JmsTemplate</code> with a default destination via the property
<code class="literal">defaultDestination</code>. The default destination will be used with send and receive
operations that do not refer to a specific destination.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-mdp" href="#jms-mdp"></a>24.2.4&nbsp;Message Listener Containers</h3></div></div></div>
<p>One of the most common uses of JMS messages in the EJB world is to drive message-driven
beans (MDBs). Spring offers a solution to create message-driven POJOs (MDPs) in a way
that does not tie a user to an EJB container. (See <a class="xref" href="jms.html#jms-asynchronousMessageReception" title="24.4.2&nbsp;Asynchronous Reception - Message-Driven POJOs">Section&nbsp;24.4.2, &#8220;Asynchronous Reception - Message-Driven POJOs&#8221;</a>
for detailed coverage of Spring&#8217;s MDP support.) As from Spring Framework 4.1, endpoint
methods can be simply annotated using <code class="literal">@JmsListener</code> see <a class="xref" href="jms.html#jms-annotated" title="24.6&nbsp;Annotation-driven listener endpoints">Section&nbsp;24.6, &#8220;Annotation-driven listener endpoints&#8221;</a> for more
details.</p>
<p>A message listener container is used to receive messages from a JMS message queue and
drive the <code class="literal">MessageListener</code> that is injected into it. The listener container is
responsible for all threading of message reception and dispatches into the listener for
processing. A message listener container is the intermediary between an MDP and a
messaging provider, and takes care of registering to receive messages, participating in
transactions, resource acquisition and release, exception conversion and suchlike. This
allows you as an application developer to write the (possibly complex) business logic
associated with receiving a message (and possibly responding to it), and delegates
boilerplate JMS infrastructure concerns to the framework.</p>
<p>There are two standard JMS message listener containers packaged with Spring, each with
its specialised feature set.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jms-mdp-simple" href="#jms-mdp-simple"></a>SimpleMessageListenerContainer</h4></div></div></div>
<p>This message listener container is the simpler of the two standard flavors. It creates a
fixed number of JMS sessions and consumers at startup, registers the listener using the
standard JMS <code class="literal">MessageConsumer.setMessageListener()</code> method, and leaves it up the JMS
provider to perform listener callbacks. This variant does not allow for dynamic adaption
to runtime demands or for participation in externally managed transactions.
Compatibility-wise, it stays very close to the spirit of the standalone JMS
specification - but is generally not compatible with Java EE&#8217;s JMS restrictions.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jms-mdp-default" href="#jms-mdp-default"></a>DefaultMessageListenerContainer</h4></div></div></div>
<p>This message listener container is the one used in most cases. In contrast to
<code class="literal">SimpleMessageListenerContainer</code>, this container variant does allow for dynamic adaption
to runtime demands and is able to participate in externally managed transactions. Each
received message is registered with an XA transaction when configured with a
<code class="literal">JtaTransactionManager</code>; so processing may take advantage of XA transaction semantics.
This listener container strikes a good balance between low requirements on the JMS
provider, advanced functionality such as transaction participation, and compatibility
with Java EE environments.</p>
<p>The cache level of the container can be customized. Note that when no caching is enabled,
a new connection and a new session is created for each message reception. Combining this
with a non durable subscription with high loads may lead to message lost. Make sure to
use a proper cache level in such case.</p>
<p>This container also has recoverable capabilities when the broker goes down. By default,
a simple <code class="literal">BackOff</code> implementation retries every 5 seconds. It is possible to specify
a custom <code class="literal">BackOff</code> implementation for more fine-grained recovery options, see
<code class="literal">ExponentialBackOff</code> for an example.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-tx" href="#jms-tx"></a>24.2.5&nbsp;Transaction management</h3></div></div></div>
<p>Spring provides a <code class="literal">JmsTransactionManager</code> that manages transactions for a single JMS
<code class="literal">ConnectionFactory</code>. This allows JMS applications to leverage the managed transaction
features of Spring as described in <a class="xref" href="transaction.html" title="12.&nbsp;Transaction Management">Chapter&nbsp;12, <i>Transaction Management</i></a>. The <code class="literal">JmsTransactionManager</code> performs
local resource transactions, binding a JMS Connection/Session pair from the specified
<code class="literal">ConnectionFactory</code> to the thread. <code class="literal">JmsTemplate</code> automatically detects such
transactional resources and operates on them accordingly.</p>
<p>In a Java EE environment, the <code class="literal">ConnectionFactory</code> will pool Connections and Sessions, so
those resources are efficiently reused across transactions. In a standalone environment,
using Spring&#8217;s <code class="literal">SingleConnectionFactory</code> will result in a shared JMS <code class="literal">Connection</code>, with
each transaction having its own independent <code class="literal">Session</code>. Alternatively, consider the use
of a provider-specific pooling adapter such as ActiveMQ&#8217;s <code class="literal">PooledConnectionFactory</code>
class.</p>
<p><code class="literal">JmsTemplate</code> can also be used with the <code class="literal">JtaTransactionManager</code> and an XA-capable JMS
<code class="literal">ConnectionFactory</code> for performing distributed transactions. Note that this requires the
use of a JTA transaction manager as well as a properly XA-configured ConnectionFactory!
(Check your Java EE server&#8217;s / JMS provider&#8217;s documentation.)</p>
<p>Reusing code across a managed and unmanaged transactional environment can be confusing
when using the JMS API to create a <code class="literal">Session</code> from a <code class="literal">Connection</code>. This is because the
JMS API has only one factory method to create a <code class="literal">Session</code> and it requires values for the
transaction and acknowledgement modes. In a managed environment, setting these values is
the responsibility of the environment&#8217;s transactional infrastructure, so these values
are ignored by the vendor&#8217;s wrapper to the JMS Connection. When using the <code class="literal">JmsTemplate</code>
in an unmanaged environment you can specify these values through the use of the
properties <code class="literal">sessionTransacted</code> and <code class="literal">sessionAcknowledgeMode</code>. When using a
<code class="literal">PlatformTransactionManager</code> with <code class="literal">JmsTemplate</code>, the template will always be given a
transactional JMS <code class="literal">Session</code>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-sending" href="#jms-sending"></a>24.3&nbsp;Sending a Message</h2></div></div></div>
<p>The <code class="literal">JmsTemplate</code> contains many convenience methods to send a message. There are send
methods that specify the destination using a <code class="literal">javax.jms.Destination</code> object and those
that specify the destination using a string for use in a JNDI lookup. The send method
that takes no destination argument uses the default destination.</p>
<pre class="programlisting"><span class="hl-keyword">import</span> javax.jms.ConnectionFactory;
<span class="hl-keyword">import</span> javax.jms.JMSException;
<span class="hl-keyword">import</span> javax.jms.Message;
<span class="hl-keyword">import</span> javax.jms.Queue;
<span class="hl-keyword">import</span> javax.jms.Session;

<span class="hl-keyword">import</span> org.springframework.jms.core.MessageCreator;
<span class="hl-keyword">import</span> org.springframework.jms.core.JmsTemplate;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JmsQueueSender {

    <span class="hl-keyword">private</span> JmsTemplate jmsTemplate;
    <span class="hl-keyword">private</span> Queue queue;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setConnectionFactory(ConnectionFactory cf) {
        <span class="hl-keyword">this</span>.jmsTemplate = <span class="hl-keyword">new</span> JmsTemplate(cf);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setQueue(Queue queue) {
        <span class="hl-keyword">this</span>.queue = queue;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> simpleSend() {
        <span class="hl-keyword">this</span>.jmsTemplate.send(<span class="hl-keyword">this</span>.queue, <span class="hl-keyword">new</span> MessageCreator() {
            <span class="hl-keyword">public</span> Message createMessage(Session session) <span class="hl-keyword">throws</span> JMSException {
                <span class="hl-keyword">return</span> session.createTextMessage(<span class="hl-string">"hello queue world"</span>);
            }
        });
    }
}</pre>
<p>This example uses the <code class="literal">MessageCreator</code> callback to create a text message from the
supplied <code class="literal">Session</code> object. The <code class="literal">JmsTemplate</code> is constructed by passing a reference to a
<code class="literal">ConnectionFactory</code>. As an alternative, a zero argument constructor and
<code class="literal">connectionFactory</code> is provided and can be used for constructing the instance in
JavaBean style (using a BeanFactory or plain Java code). Alternatively, consider
deriving from Spring&#8217;s <code class="literal">JmsGatewaySupport</code> convenience base class, which provides
pre-built bean properties for JMS configuration.</p>
<p>The method <code class="literal">send(String destinationName, MessageCreator creator)</code> lets you send a
message using the string name of the destination. If these names are registered in JNDI,
you should set the <code class="literal">destinationResolver</code> property of the template to an instance of
<code class="literal">JndiDestinationResolver</code>.</p>
<p>If you created the <code class="literal">JmsTemplate</code> and specified a default destination, the
<code class="literal">send(MessageCreator c)</code> sends a message to that destination.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-msg-conversion" href="#jms-msg-conversion"></a>24.3.1&nbsp;Using Message Converters</h3></div></div></div>
<p>In order to facilitate the sending of domain model objects, the <code class="literal">JmsTemplate</code> has
various send methods that take a Java object as an argument for a message&#8217;s data
content. The overloaded methods <code class="literal">convertAndSend()</code> and <code class="literal">receiveAndConvert()</code> in
<code class="literal">JmsTemplate</code> delegate the conversion process to an instance of the <code class="literal">MessageConverter</code>
interface. This interface defines a simple contract to convert between Java objects and
JMS messages. The default implementation <code class="literal">SimpleMessageConverter</code> supports conversion
between <code class="literal">String</code> and <code class="literal">TextMessage</code>, <code class="literal">byte[]</code> and <code class="literal">BytesMesssage</code>, and <code class="literal">java.util.Map</code>
and <code class="literal">MapMessage</code>. By using the converter, you and your application code can focus on the
business object that is being sent or received via JMS and not be concerned with the
details of how it is represented as a JMS message.</p>
<p>The sandbox currently includes a <code class="literal">MapMessageConverter</code> which uses reflection to convert
between a JavaBean and a <code class="literal">MapMessage</code>. Other popular implementation choices you might
implement yourself are Converters that use an existing XML marshalling package, such as
JAXB, Castor, XMLBeans, or XStream, to create a <code class="literal">TextMessage</code> representing the object.</p>
<p>To accommodate the setting of a message&#8217;s properties, headers, and body that can not be
generically encapsulated inside a converter class, the <code class="literal">MessagePostProcessor</code> interface
gives you access to the message after it has been converted, but before it is sent. The
example below demonstrates how to modify a message header and a property after a
<code class="literal">java.util.Map</code> is converted to a message.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> sendWithConversion() {
    Map map = <span class="hl-keyword">new</span> HashMap();
    map.put(<span class="hl-string">"Name"</span>, <span class="hl-string">"Mark"</span>);
    map.put(<span class="hl-string">"Age"</span>, <span class="hl-keyword">new</span> Integer(<span class="hl-number">47</span>));
    jmsTemplate.convertAndSend(<span class="hl-string">"testQueue"</span>, map, <span class="hl-keyword">new</span> MessagePostProcessor() {
        <span class="hl-keyword">public</span> Message postProcessMessage(Message message) <span class="hl-keyword">throws</span> JMSException {
            message.setIntProperty(<span class="hl-string">"AccountID"</span>, <span class="hl-number">1234</span>);
            message.setJMSCorrelationID(<span class="hl-string">"123-00001"</span>);
            <span class="hl-keyword">return</span> message;
        }
    });
}</pre>
<p>This results in a message of the form:</p>
<pre class="literallayout">MapMessage={
	Header={
		... standard headers ...
		CorrelationID={123-00001}
	}
	Properties={
		AccountID={Integer:1234}
	}
	Fields={
		Name={String:Mark}
		Age={Integer:47}
	}
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-callbacks" href="#jms-callbacks"></a>24.3.2&nbsp;SessionCallback and ProducerCallback</h3></div></div></div>
<p>While the send operations cover many common usage scenarios, there are cases when you
want to perform multiple operations on a JMS <code class="literal">Session</code> or <code class="literal">MessageProducer</code>. The
<code class="literal">SessionCallback</code> and <code class="literal">ProducerCallback</code> expose the JMS <code class="literal">Session</code> and <code class="literal">Session</code> /
<code class="literal">MessageProducer</code> pair respectively. The <code class="literal">execute()</code> methods on <code class="literal">JmsTemplate</code> execute
these callback methods.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-receiving" href="#jms-receiving"></a>24.4&nbsp;Receiving a message</h2></div></div></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-receiving-sync" href="#jms-receiving-sync"></a>24.4.1&nbsp;Synchronous Reception</h3></div></div></div>
<p>While JMS is typically associated with asynchronous processing, it is possible to
consume messages synchronously. The overloaded <code class="literal">receive(..)</code> methods provide this
functionality. During a synchronous receive, the calling thread blocks until a message
becomes available. This can be a dangerous operation since the calling thread can
potentially be blocked indefinitely. The property <code class="literal">receiveTimeout</code> specifies how long
the receiver should wait before giving up waiting for a message.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-asynchronousMessageReception" href="#jms-asynchronousMessageReception"></a>24.4.2&nbsp;Asynchronous Reception - Message-Driven POJOs</h3></div></div></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Spring also supports annotated-listener endpoints through the use of the <code class="literal">@JmsListener</code>
annotation and provides an open infrastructure to register endpoints programmatically. This
is by far the most convenient way to setup an asynchronous receiver, see
<a class="xref" href="jms.html#jms-annotated-support" title="24.6.1&nbsp;Enable listener endpoint annotations">Section&nbsp;24.6.1, &#8220;Enable listener endpoint annotations&#8221;</a> for more details.</p>
</td></tr></table></div>
<p>In a fashion similar to a Message-Driven Bean (MDB) in the EJB world, the Message-Driven
POJO (MDP) acts as a receiver for JMS messages. The one restriction (but see also below
for the discussion of the <code class="literal">MessageListenerAdapter</code> class) on an MDP is that it must
implement the <code class="literal">javax.jms.MessageListener</code> interface. Please also be aware that in the
case where your POJO will be receiving messages on multiple threads, it is important to
ensure that your implementation is thread-safe.</p>
<p>Below is a simple implementation of an MDP:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> javax.jms.JMSException;
<span class="hl-keyword">import</span> javax.jms.Message;
<span class="hl-keyword">import</span> javax.jms.MessageListener;
<span class="hl-keyword">import</span> javax.jms.TextMessage;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExampleListener <span class="hl-keyword">implements</span> MessageListener {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> onMessage(Message message) {
        <span class="hl-keyword">if</span> (message <span class="hl-keyword">instanceof</span> TextMessage) {
            <span class="hl-keyword">try</span> {
                System.out.println(((TextMessage) message).getText());
            }
            <span class="hl-keyword">catch</span> (JMSException ex) {
                <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> RuntimeException(ex);
            }
        }
        <span class="hl-keyword">else</span> {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(<span class="hl-string">"Message must be of type TextMessage"</span>);
        }
    }

}</pre>
<p>Once you&#8217;ve implemented your <code class="literal">MessageListener</code>, it&#8217;s time to create a message listener
container.</p>
<p>Find below an example of how to define and configure one of the message listener
containers that ships with Spring (in this case the <code class="literal">DefaultMessageListenerContainer</code>).</p>
<pre class="programlisting"><span class="hl-comment">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span>
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"messageListener"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"jmsexample.ExampleListener"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-comment">&lt;!-- and this is the message listener container --&gt;</span>
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsContainer"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"destination"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"destination"</span><span class="hl-tag">/&gt;</span>
    <span class="strong"><strong>&lt;property name="messageListener" ref="messageListener" /&gt;</strong></span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Please refer to the Spring javadocs of the various message listener containers for a full
description of the features supported by each implementation.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-receiving-async-session-aware-message-listener" href="#jms-receiving-async-session-aware-message-listener"></a>24.4.3&nbsp;the SessionAwareMessageListener interface</h3></div></div></div>
<p>The <code class="literal">SessionAwareMessageListener</code> interface is a Spring-specific interface that provides
a similar contract to the JMS <code class="literal">MessageListener</code> interface, but also provides the message
handling method with access to the JMS <code class="literal">Session</code> from which the <code class="literal">Message</code> was received.</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.jms.listener;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> SessionAwareMessageListener {

    <span class="hl-keyword">void</span> onMessage(Message message, Session session) <span class="hl-keyword">throws</span> JMSException;

}</pre>
<p>You can choose to have your MDPs implement this interface (in preference to the standard
JMS <code class="literal">MessageListener</code> interface) if you want your MDPs to be able to respond to any
received messages (using the <code class="literal">Session</code> supplied in the <code class="literal">onMessage(Message, Session)</code>
method). All of the message listener container implementations that ship with Spring
have support for MDPs that implement either the <code class="literal">MessageListener</code> or
<code class="literal">SessionAwareMessageListener</code> interface. Classes that implement the
<code class="literal">SessionAwareMessageListener</code> come with the caveat that they are then tied to Spring
through the interface. The choice of whether or not to use it is left entirely up to you
as an application developer or architect.</p>
<p>Please note that the <code class="literal">'onMessage(..)'</code> method of the <code class="literal">SessionAwareMessageListener</code>
interface throws <code class="literal">JMSException</code>. In contrast to the standard JMS <code class="literal">MessageListener</code>
interface, when using the <code class="literal">SessionAwareMessageListener</code> interface, it is the
responsibility of the client code to handle any exceptions thrown.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-receiving-async-message-listener-adapter" href="#jms-receiving-async-message-listener-adapter"></a>24.4.4&nbsp;the MessageListenerAdapter</h3></div></div></div>
<p>The <code class="literal">MessageListenerAdapter</code> class is the final component in Spring&#8217;s asynchronous
messaging support: in a nutshell, it allows you to expose almost <span class="emphasis"><em>any</em></span> class as a MDP
(there are of course some constraints).</p>
<p>Consider the following interface definition. Notice that although the interface extends
neither the <code class="literal">MessageListener</code> nor <code class="literal">SessionAwareMessageListener</code> interfaces, it can still
be used as a MDP via the use of the <code class="literal">MessageListenerAdapter</code> class. Notice also how the
various message handling methods are strongly typed according to the <span class="emphasis"><em>contents</em></span> of the
various <code class="literal">Message</code> types that they can receive and handle.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MessageDelegate {

    <span class="hl-keyword">void</span> handleMessage(String message);

    <span class="hl-keyword">void</span> handleMessage(Map message);

    <span class="hl-keyword">void</span> handleMessage(<span class="hl-keyword">byte</span>[] message);

    <span class="hl-keyword">void</span> handleMessage(Serializable message);

}</pre>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DefaultMessageDelegate <span class="hl-keyword">implements</span> MessageDelegate {
    <span class="hl-comment">// implementation elided for clarity...</span>
}</pre>
<p>In particular, note how the above implementation of the <code class="literal">MessageDelegate</code> interface (the
above <code class="literal">DefaultMessageDelegate</code> class) has <span class="emphasis"><em>no</em></span> JMS dependencies at all. It truly is a
POJO that we will make into an MDP via the following configuration.</p>
<pre class="programlisting"><span class="hl-comment">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span>
<span class="strong"><strong>&lt;bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="jmsexample.DefaultMessageDelegate"/&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</strong></span>

<span class="hl-comment">&lt;!-- and this is the message listener container... --&gt;</span>
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsContainer"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"destination"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"destination"</span><span class="hl-tag">/&gt;</span>
    <span class="strong"><strong>&lt;property name="messageListener" ref="messageListener" /&gt;</strong></span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Below is an example of another MDP that can only handle the receiving of JMS
<code class="literal">TextMessage</code> messages. Notice how the message handling method is actually called
<code class="literal">'receive'</code> (the name of the message handling method in a <code class="literal">MessageListenerAdapter</code>
defaults to <code class="literal">'handleMessage'</code>), but it is configurable (as you will see below). Notice
also how the <code class="literal">'receive(..)'</code> method is strongly typed to receive and respond only to JMS
<code class="literal">TextMessage</code> messages.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> TextMessageDelegate {

    <span class="hl-keyword">void</span> receive(TextMessage message);

}</pre>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DefaultTextMessageDelegate <span class="hl-keyword">implements</span> TextMessageDelegate {
    <span class="hl-comment">// implementation elided for clarity...</span>
}</pre>
<p>The configuration of the attendant <code class="literal">MessageListenerAdapter</code> would look like this:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"messageListener"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jms.listener.adapter.MessageListenerAdapter"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"jmsexample.DefaultTextMessageDelegate"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/constructor-arg&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"defaultListenerMethod"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"receive"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-comment">&lt;!-- we don't want automatic message context extraction --&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"messageConverter"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;null/&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Please note that if the above <code class="literal">'messageListener'</code> receives a JMS <code class="literal">Message</code> of a type
other than <code class="literal">TextMessage</code>, an <code class="literal">IllegalStateException</code> will be thrown (and subsequently
swallowed). Another of the capabilities of the <code class="literal">MessageListenerAdapter</code> class is the
ability to automatically send back a response <code class="literal">Message</code> if a handler method returns a
non-void value. Consider the interface and class:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ResponsiveTextMessageDelegate {

    <span class="hl-comment">// notice the return type...</span>
    String receive(TextMessage message);

}</pre>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DefaultResponsiveTextMessageDelegate <span class="hl-keyword">implements</span> ResponsiveTextMessageDelegate {
    <span class="hl-comment">// implementation elided for clarity...</span>
}</pre>
<p>If the above <code class="literal">DefaultResponsiveTextMessageDelegate</code> is used in conjunction with a
<code class="literal">MessageListenerAdapter</code> then any non-null value that is returned from the execution of
the <code class="literal">'receive(..)'</code> method will (in the default configuration) be converted into a
<code class="literal">TextMessage</code>. The resulting <code class="literal">TextMessage</code> will then be sent to the <code class="literal">Destination</code> (if
one exists) defined in the JMS Reply-To property of the original <code class="literal">Message</code>, or the
default <code class="literal">Destination</code> set on the <code class="literal">MessageListenerAdapter</code> (if one has been configured);
if no <code class="literal">Destination</code> is found then an <code class="literal">InvalidDestinationException</code> will be thrown (and
please note that this exception <span class="emphasis"><em>will not</em></span> be swallowed and <span class="emphasis"><em>will</em></span> propagate up the
call stack).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-tx-participation" href="#jms-tx-participation"></a>24.4.5&nbsp;Processing messages within transactions</h3></div></div></div>
<p>Invoking a message listener within a transaction only requires reconfiguration of the
listener container.</p>
<p>Local resource transactions can simply be activated through the <code class="literal">sessionTransacted</code> flag
on the listener container definition. Each message listener invocation will then operate
within an active JMS transaction, with message reception rolled back in case of listener
execution failure. Sending a response message (via <code class="literal">SessionAwareMessageListener</code>) will
be part of the same local transaction, but any other resource operations (such as
database access) will operate independently. This usually requires duplicate message
detection in the listener implementation, covering the case where database processing
has committed but message processing failed to commit.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsContainer"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"destination"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"destination"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"messageListener"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"messageListener"</span><span class="hl-tag">/&gt;</span>
    <span class="strong"><strong>&lt;property name="sessionTransacted" value="true"/&gt;</strong></span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>For participating in an externally managed transaction, you will need to configure a
transaction manager and use a listener container which supports externally managed
transactions: typically <code class="literal">DefaultMessageListenerContainer</code>.</p>
<p>To configure a message listener container for XA transaction participation, you&#8217;ll want
to configure a <code class="literal">JtaTransactionManager</code> (which, by default, delegates to the Java EE
server&#8217;s transaction subsystem). Note that the underlying JMS ConnectionFactory needs to
be XA-capable and properly registered with your JTA transaction coordinator! (Check your
Java EE server&#8217;s configuration of JNDI resources.) This allows message reception as well
as e.g. database access to be part of the same transaction (with unified commit
semantics, at the expense of XA transaction log overhead).</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.transaction.jta.JtaTransactionManager"</span><span class="hl-tag">/&gt;</span></pre>
<p>Then you just need to add it to our earlier container configuration. The container will
take care of the rest.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsContainer"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"destination"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"destination"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"messageListener"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"messageListener"</span><span class="hl-tag">/&gt;</span>
    <span class="strong"><strong>&lt;property name="transactionManager" ref="transactionManager"/&gt;</strong></span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-jca-message-endpoint-manager" href="#jms-jca-message-endpoint-manager"></a>24.5&nbsp;Support for JCA Message Endpoints</h2></div></div></div>
<p>Beginning with version 2.5, Spring also provides support for a JCA-based
<code class="literal">MessageListener</code> container. The <code class="literal">JmsMessageEndpointManager</code> will attempt to
automatically determine the <code class="literal">ActivationSpec</code> class name from the provider&#8217;s
<code class="literal">ResourceAdapter</code> class name. Therefore, it is typically possible to just provide
Spring&#8217;s generic <code class="literal">JmsActivationSpecConfig</code> as shown in the following example.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"resourceAdapter"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"resourceAdapter"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"activationSpecConfig"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"destinationName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"myQueue"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"messageListener"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myMessageListener"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Alternatively, you may set up a <code class="literal">JmsMessageEndpointManager</code> with a given
<code class="literal">ActivationSpec</code> object. The <code class="literal">ActivationSpec</code> object may also come from a JNDI lookup
(using <code class="literal">&lt;jee:jndi-lookup&gt;</code>).</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"resourceAdapter"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"resourceAdapter"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"activationSpec"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.apache.activemq.ra.ActiveMQActivationSpec"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"destination"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"myQueue"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"destinationType"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"javax.jms.Queue"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"messageListener"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myMessageListener"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Using Spring&#8217;s <code class="literal">ResourceAdapterFactoryBean</code>, the target <code class="literal">ResourceAdapter</code> may be
configured locally as depicted in the following example.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"resourceAdapter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.support.ResourceAdapterFactoryBean"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"resourceAdapter"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.apache.activemq.ra.ActiveMQResourceAdapter"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"serverUrl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tcp://localhost:61616"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"workManager"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jca.work.SimpleTaskWorkManager"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>The specified <code class="literal">WorkManager</code> may also point to an environment-specific thread pool -
typically through <code class="literal">SimpleTaskWorkManager's</code> "asyncTaskExecutor" property. Consider
defining a shared thread pool for all your <code class="literal">ResourceAdapter</code> instances if you happen to
use multiple adapters.</p>
<p>In some environments (e.g. WebLogic 9 or above), the entire <code class="literal">ResourceAdapter</code> object may
be obtained from JNDI instead (using <code class="literal">&lt;jee:jndi-lookup&gt;</code>). The Spring-based message
listeners can then interact with the server-hosted <code class="literal">ResourceAdapter</code>, also using the
server&#8217;s built-in <code class="literal">WorkManager</code>.</p>
<p>Please consult the JavaDoc for <code class="literal">JmsMessageEndpointManager</code>, <code class="literal">JmsActivationSpecConfig</code>,
and <code class="literal">ResourceAdapterFactoryBean</code> for more details.</p>
<p>Spring also provides a generic JCA message endpoint manager which is not tied to JMS:
<code class="literal">org.springframework.jca.endpoint.GenericMessageEndpointManager</code>. This component allows
for using any message listener type (e.g. a CCI MessageListener) and any
provider-specific ActivationSpec object. Check out your JCA provider&#8217;s documentation to
find out about the actual capabilities of your connector, and consult
<code class="literal">GenericMessageEndpointManager</code>'s JavaDoc for the Spring-specific configuration details.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>JCA-based message endpoint management is very analogous to EJB 2.1 Message-Driven Beans;
it uses the same underlying resource provider contract. Like with EJB 2.1 MDBs, any
message listener interface supported by your JCA provider can be used in the Spring
context as well. Spring nevertheless provides explicit <span class="emphasis"><em>convenience</em></span> support for JMS,
simply because JMS is the most common endpoint API used with the JCA endpoint management
contract.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-annotated" href="#jms-annotated"></a>24.6&nbsp;Annotation-driven listener endpoints</h2></div></div></div>
<p>The easiest way to receive a message asynchronously is to use the annotated listener
endpoint infrastructure. In a nutshell, it allows you to expose a method of a managed
bean as a JMS listener endpoint.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Component</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

    <em><span class="hl-annotation" style="color: gray">@JmsListener(destination = "myDestination")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processOrder(String data) { ... }
}</pre>
<p>The idea of the example above is that whenever a message is available on the
<code class="literal">javax.jms.Destination</code> "myDestination", the <code class="literal">processOrder</code> method is invoked
accordingly (in this case, with the content of the JMS message similarly to
what the <a class="link" href="jms.html#jms-receiving-async-message-listener-adapter" title="24.4.4&nbsp;the MessageListenerAdapter"><code class="literal">MessageListenerAdapter</code></a>
provides).</p>
<p>The annotated endpoint infrastructure creates a message listener container
behind the scenes for each annotated method, using a <code class="literal">JmsListenerContainerFactory</code>.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-annotated-support" href="#jms-annotated-support"></a>24.6.1&nbsp;Enable listener endpoint annotations</h3></div></div></div>
<p>To enable support for <code class="literal">@JmsListener</code> annotations add <code class="literal">@EnableJms</code> to one of
your <code class="literal">@Configuration</code> classes.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableJms</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
        DefaultJmsListenerContainerFactory factory =
                <span class="hl-keyword">new</span> DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory());
        factory.setDestinationResolver(destinationResolver());
        factory.setConcurrency(<span class="hl-string">"3-10"</span>);
        <span class="hl-keyword">return</span> factory;
    }
}</pre>
<p>By default, the infrastructure looks for a bean named <code class="literal">jmsListenerContainerFactory</code>
as the source for the factory to use to create message listener containers. In this
case, and ignoring the JMS infrastructure setup, the <code class="literal">processOrder</code> method can be
invoked with a core poll size of 3 threads and a maximum pool size of 10 threads.</p>
<p>It is possible to customize the listener container factory to use per annotation or
an explicit default can be configured by implementing the <code class="literal">JmsListenerConfigurer</code>
interface. The default is only required if at least one endpoint is registered
without a specific container factory. See the javadoc for full details and examples.</p>
<p>If you prefer <a class="link" href="jms.html#jms-namespace" title="24.7&nbsp;JMS Namespace Support">XML configuration</a> use the <code class="literal">&lt;jms:annotation-driven&gt;</code>
element.</p>
<pre class="programlisting"><span class="hl-tag">&lt;jms:annotation-driven/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsListenerContainerFactory"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jms.config.DefaultJmsListenerContainerFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"destinationResolver"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"destinationResolver"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"concurrency"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"3-10"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-annotated-programmatic-registration" href="#jms-annotated-programmatic-registration"></a>24.6.2&nbsp;Programmatic endpoints registration</h3></div></div></div>
<p><code class="literal">JmsListenerEndpoint</code> provides a model of an JMS endpoint and is responsible for configuring
the container for that model. The infrastructure allows you to configure endpoints
programmatically in addition to the ones that are detected by the <code class="literal">JmsListener</code> annotation.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableJms</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig <span class="hl-keyword">implements</span> JmsListenerConfigurer {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
        SimpleJmsListenerEndpoint endpoint = <span class="hl-keyword">new</span> SimpleJmsListenerEndpoint();
        endpoint.setId(<span class="hl-string">"myJmsEndpoint"</span>);
        endpoint.setDestination(<span class="hl-string">"anotherQueue"</span>);
        endpoint.setMessageListener(message -&gt; {
            <span class="hl-comment">// processing</span>
        });
        registrar.registerEndpoint(endpoint);
    }
}</pre>
<p>In the example above, we used <code class="literal">SimpleJmsListenerEndpoint</code> which provides the actual
<code class="literal">MessageListener</code> to invoke but you could just as well build your own endpoint variant
describing a custom invocation mechanism.</p>
<p>It should be noted that you could just as well skip the use of <code class="literal">@JmsListener</code> altogether
and only register your endpoints programmatically through <code class="literal">JmsListenerConfigurer</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-annotated-method-signature" href="#jms-annotated-method-signature"></a>24.6.3&nbsp;Annotated endpoint method signature</h3></div></div></div>
<p>So far, we have been injecting a simple <code class="literal">String</code> in our endpoint but it can actually
have a very flexible method signature. Let&#8217;s rewrite it to inject the <code class="literal">Order</code> with
a custom header:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Component</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

    <em><span class="hl-annotation" style="color: gray">@JmsListener(destination = "myDestination")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processOrder(Order order, <em><span class="hl-annotation" style="color: gray">@Header("order_type")</span></em> String orderType) {
        ...
    }
}</pre>
<p>These are the main elements you can inject in JMS listener endpoints:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The raw <code class="literal">javax.jms.Message</code> or any of its subclasses (provided of course that it
matches the incoming message type).
</li><li class="listitem">
The <code class="literal">javax.jms.Session</code> for optional access to the native JMS API e.g. for sending
a custom reply.
</li><li class="listitem">
The <code class="literal">org.springframework.messaging.Message</code> representing the incoming JMS message.
Note that this message holds both the custom and the standard headers (as defined
by <code class="literal">JmsHeaders</code>).
</li><li class="listitem">
<code class="literal">@Header</code>-annotated method arguments to extract a specific header value, including
standard JMS headers.
</li><li class="listitem">
<code class="literal">@Headers</code>-annotated argument that must also be assignable to <code class="literal">java.util.Map</code> for
getting access to all headers.
</li><li class="listitem">
A non-annotated element that is not one of the supported types (i.e. <code class="literal">Message</code> and
<code class="literal">Session</code>) is considered to be the payload. You can make that explicit by annotating
the parameter with <code class="literal">@Payload</code>. You can also turn on validation by adding an extra
<code class="literal">@Valid</code>.
</li></ul></div>
<p>The ability to inject Spring&#8217;s <code class="literal">Message</code> abstraction is particularly useful to benefit
from all the information stored in the transport-specific message without relying on
transport-specific API.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@JmsListener(destination = "myDestination")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processOrder(Message&lt;Order&gt; order) { ... }</pre>
<p>Handling of method arguments is provided by <code class="literal">DefaultMessageHandlerMethodFactory</code> which can be
further customized to support additional method arguments. The conversion and validation
support can be customized there as well.</p>
<p>For instance, if we want to make sure our <code class="literal">Order</code> is valid before processing it, we can
annotate the payload with <code class="literal">@Valid</code> and configure the necessary validator as follows:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableJms</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig <span class="hl-keyword">implements</span> JmsListenerConfigurer {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
        registrar.setMessageHandlerMethodFactory(myJmsHandlerMethodFactory());
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> DefaultMessageHandlerMethodFactory myHandlerMethodFactory() {
        DefaultMessageHandlerMethodFactory factory = <span class="hl-keyword">new</span> DefaultMessageHandlerMethodFactory();
        factory.setValidator(myValidator());
        <span class="hl-keyword">return</span> factory;
    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jms-annotated-reply" href="#jms-annotated-reply"></a>24.6.4&nbsp;Reply management</h3></div></div></div>
<p>The existing support in <a class="link" href="jms.html#jms-receiving-async-message-listener-adapter" title="24.4.4&nbsp;the MessageListenerAdapter">MessageListenerAdapter</a>
already allows your method to have a non-<code class="literal">void</code> return type. When that&#8217;s the case, the result of
the invocation is encapsulated in a <code class="literal">javax.jms.Message</code> sent either in the destination specified
in the <code class="literal">JMSReplyTo</code> header of the original message or in the default destination configured on
the listener. That default destination can now be set using the <code class="literal">@SendTo</code> annotation of the
messaging abstraction.</p>
<p>Assuming our <code class="literal">processOrder</code> method should now return an <code class="literal">OrderStatus</code>, it is possible to write it
as follow to automatically send a reply:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@JmsListener(destination = "myDestination")</span></em>
<em><span class="hl-annotation" style="color: gray">@SendTo("status")</span></em>
<span class="hl-keyword">public</span> OrderStatus processOrder(Order order) {
    <span class="hl-comment">// order processing</span>
    <span class="hl-keyword">return</span> status;
}</pre>
<p>If you need to set additional headers in a transport-independent manner, you could return a
<code class="literal">Message</code> instead, something like:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@JmsListener(destination = "myDestination")</span></em>
<em><span class="hl-annotation" style="color: gray">@SendTo("status")</span></em>
<span class="hl-keyword">public</span> Message&lt;OrderStatus&gt; processOrder(Order order) {
    <span class="hl-comment">// order processing</span>
    <span class="hl-keyword">return</span> MessageBuilder
            .withPayload(status)
            .setHeader(<span class="hl-string">"code"</span>, <span class="hl-number">1234</span>)
            .build();
}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-namespace" href="#jms-namespace"></a>24.7&nbsp;JMS Namespace Support</h2></div></div></div>
<p>Spring provides an XML namespace for simplifying JMS configuration. To use the JMS
namespace elements you will need to reference the JMS schema:</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
        <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
        <span class="strong"><strong>xmlns:jms="http://www.springframework.org/schema/jms"</strong></span>
        xsi:schemaLocation="
            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
            <span class="strong"><strong>http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd</strong></span>"&gt;

    <span class="hl-comment">&lt;!-- bean definitions here --&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>
<p>The namespace consists of three top-level elements: <code class="literal">&lt;annotation-driven/&gt;</code>, <code class="literal">&lt;listener-container/&gt;</code>
and <code class="literal">&lt;jca-listener-container/&gt;</code>. <code class="literal">&lt;annotation-driven</code> enables the use of <a class="link" href="jms.html#jms-annotated" title="24.6&nbsp;Annotation-driven listener endpoints">annotation-driven listener endpoints</a>. <code class="literal">&lt;listener-container/&gt;</code> and <code class="literal">&lt;jca-listener-container/&gt;</code>
defines shared listener container configuration and may contain <code class="literal">&lt;listener/&gt;</code> child elements. Here
is an example of a basic configuration for two listeners.</p>
<pre class="programlisting"><span class="hl-tag">&lt;jms:listener-container&gt;</span>

    <span class="hl-tag">&lt;jms:listener</span> <span class="hl-attribute">destination</span>=<span class="hl-value">"queue.orders"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"orderService"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"placeOrder"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;jms:listener</span> <span class="hl-attribute">destination</span>=<span class="hl-value">"queue.confirmations"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"confirmationLogger"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"log"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/jms:listener-container&gt;</span></pre>
<p>The example above is equivalent to creating two distinct listener container bean
definitions and two distinct <code class="literal">MessageListenerAdapter</code> bean definitions as demonstrated
in <a class="xref" href="jms.html#jms-receiving-async-message-listener-adapter" title="24.4.4&nbsp;the MessageListenerAdapter">Section&nbsp;24.4.4, &#8220;the MessageListenerAdapter&#8221;</a>. In addition to the attributes shown
above, the <code class="literal">listener</code> element may contain several optional ones. The following table
describes all available attributes:</p>
<div class="table"><a name="jms-namespace-listener-tbl" href="#jms-namespace-listener-tbl"></a><p class="title"><b>Table&nbsp;24.1.&nbsp;Attributes of the JMS &lt;listener&gt; element</b></p><div class="table-contents">
<table summary="Attributes of the JMS <listener&gt; element" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>id</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A bean name for the hosting listener container. If not specified, a bean name will be
automatically generated.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>destination <span class="emphasis"><em>(required)</em></span></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The destination name for this listener, resolved through the <code class="literal">DestinationResolver</code>
strategy.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ref <span class="emphasis"><em>(required)</em></span></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The bean name of the handler object.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>method</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The name of the handler method to invoke. If the <code class="literal">ref</code> points to a <code class="literal">MessageListener</code>
or Spring <code class="literal">SessionAwareMessageListener</code>, this attribute may be omitted.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>response-destination</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The name of the default response destination to send response messages to. This will
be applied in case of a request message that does not carry a "JMSReplyTo" field. The
type of this destination will be determined by the listener-container&#8217;s
"destination-type" attribute. Note: This only applies to a listener method with a
return value, for which each result object will be converted into a response message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>subscription</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The name of the durable subscription, if any.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>selector</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>An optional message selector for this listener.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>concurrency</p></td><td style="" align="left" valign="top"><p>The number of concurrent sessions/consumers to start for this listener. Can either be
a simple number indicating the maximum number (e.g. "5") or a range indicating the lower
as well as the upper limit (e.g. "3-5"). Note that a specified minimum is just a hint
and might be ignored at runtime. Default is the value provided by the container</p></td></tr></tbody></table>
</div></div><br class="table-break">
<p>The <code class="literal">&lt;listener-container/&gt;</code> element also accepts several optional attributes. This
allows for customization of the various strategies (for example, <code class="literal">taskExecutor</code> and
<code class="literal">destinationResolver</code>) as well as basic JMS settings and resource references. Using
these attributes, it is possible to define highly-customized listener containers while
still benefiting from the convenience of the namespace.</p>
<p>Such settings can be automatically exposed as a <code class="literal">JmsListenerContainerFactory</code> by
specifying the id of the bean to expose through the <code class="literal">factory-id</code> attribute.</p>
<pre class="programlisting"><span class="hl-tag">&lt;jms:listener-container</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"myConnectionFactory"</span>
        <span class="hl-attribute">task-executor</span>=<span class="hl-value">"myTaskExecutor"</span>
        <span class="hl-attribute">destination-resolver</span>=<span class="hl-value">"myDestinationResolver"</span>
        <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"myTransactionManager"</span>
        <span class="hl-attribute">concurrency</span>=<span class="hl-value">"10"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;jms:listener</span> <span class="hl-attribute">destination</span>=<span class="hl-value">"queue.orders"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"orderService"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"placeOrder"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;jms:listener</span> <span class="hl-attribute">destination</span>=<span class="hl-value">"queue.confirmations"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"confirmationLogger"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"log"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/jms:listener-container&gt;</span></pre>
<p>The following table describes all available attributes. Consult the class-level javadocs
of the <code class="literal">AbstractMessageListenerContainer</code> and its concrete subclasses for more details
on the individual properties. The javadocs also provide a discussion of transaction
choices and message redelivery scenarios.</p>
<div class="table"><a name="jms-namespace-listener-container-tbl" href="#jms-namespace-listener-container-tbl"></a><p class="title"><b>Table&nbsp;24.2.&nbsp;Attributes of the JMS &lt;listener-container&gt; element</b></p><div class="table-contents">
<table summary="Attributes of the JMS <listener-container&gt; element" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>container-type</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The type of this listener container. Available options are: <code class="literal">default</code>, <code class="literal">simple</code>,
<code class="literal">default102</code>, or <code class="literal">simple102</code> (the default value is <code class="literal">'default'</code>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>container-class</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A custom listener container implementation class as fully qualified class name.
Default is Spring&#8217;s standard <code class="literal">DefaultMessageListenerContainer</code> or
<code class="literal">SimpleMessageListenerContainer</code>, according to the "container-type" attribute.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>factory-id</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Exposes the settings defined by this element as a <code class="literal">JmsListenerContainerFactory</code>
with the specified id so that they can be reused with other endpoints.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>connection-factory</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to the JMS <code class="literal">ConnectionFactory</code> bean (the default bean name is
<code class="literal">'connectionFactory'</code>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>task-executor</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to the Spring <code class="literal">TaskExecutor</code> for the JMS listener invokers.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>destination-resolver</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to the <code class="literal">DestinationResolver</code> strategy for resolving JMS <code class="literal">Destinations</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>message-converter</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to the <code class="literal">MessageConverter</code> strategy for converting JMS Messages to listener
method arguments. Default is a <code class="literal">SimpleMessageConverter</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>error-handler</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to an <code class="literal">ErrorHandler</code> strategy for handling any uncaught Exceptions that
may occur during the execution of the <code class="literal">MessageListener</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>destination-type</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The JMS destination type for this listener: <code class="literal">queue</code>, <code class="literal">topic</code>, <code class="literal">durableTopic</code>, <code class="literal">sharedTopic</code>
or <code class="literal">sharedDurableTopic</code>. This enables potentially the <code class="literal">pubSubDomain</code>, <code class="literal">subscriptionDurable</code>
and <code class="literal">subscriptionShared</code> properties of the container. The default is <code class="literal">queue</code> (i.e. disabling
those 3 properties).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>client-id</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The JMS client id for this listener container. Needs to be specified when using
durable subscriptions.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>cache</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The cache level for JMS resources: <code class="literal">none</code>, <code class="literal">connection</code>, <code class="literal">session</code>, <code class="literal">consumer</code> or
<code class="literal">auto</code>. By default ( <code class="literal">auto</code>), the cache level will effectively be "consumer", unless
an external transaction manager has been specified - in which case the effective
default will be <code class="literal">none</code> (assuming Java EE-style transaction management where the given
ConnectionFactory is an XA-aware pool).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>acknowledge</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The native JMS acknowledge mode: <code class="literal">auto</code>, <code class="literal">client</code>, <code class="literal">dups-ok</code> or <code class="literal">transacted</code>. A value
of <code class="literal">transacted</code> activates a locally transacted <code class="literal">Session</code>. As an alternative, specify
the <code class="literal">transaction-manager</code> attribute described below. Default is <code class="literal">auto</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>transaction-manager</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to an external <code class="literal">PlatformTransactionManager</code> (typically an XA-based
transaction coordinator, e.g. Spring&#8217;s <code class="literal">JtaTransactionManager</code>). If not specified,
native acknowledging will be used (see "acknowledge" attribute).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>concurrency</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The number of concurrent sessions/consumers to start for each listener. Can either be
a simple number indicating the maximum number (e.g. "5") or a range indicating the
lower as well as the upper limit (e.g. "3-5"). Note that a specified minimum is just a
hint and might be ignored at runtime. Default is 1; keep concurrency limited to 1 in
case of a topic listener or if queue ordering is important; consider raising it for
general queues.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>prefetch</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The maximum number of messages to load into a single session. Note that raising this
number might lead to starvation of concurrent consumers!</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>receive-timeout</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The timeout to use for receive calls (in milliseconds). The default is <code class="literal">1000</code> ms (1
sec); <code class="literal">-1</code> indicates no timeout at all.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>back-off</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Specify the <code class="literal">BackOff</code> instance to use to compute the interval between recovery
attempts. If the <code class="literal">BackOffExecution</code> implementation returns <code class="literal">BackOffExecution#STOP</code>,
the listener container will not further attempt to recover. The <code class="literal">recovery-interval</code>
value is ignored when this property is set. The default is a <code class="literal">FixedBackOff</code> with
an interval of 5000 ms, that is 5 seconds.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>recovery-interval</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Specify the interval between recovery attempts, in milliseconds. Convenience
way to create a <code class="literal">FixedBackOff</code> with the specified interval. For more recovery
options, consider specifying a BackOff instance instead. The default is 5000 ms,
that is 5 seconds.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>phase</p></td><td style="" align="left" valign="top"><p>The lifecycle phase within which this container should start and stop. The lower the
value the earlier this container will start and the later it will stop. The default is
<code class="literal">Integer.MAX_VALUE</code> meaning the container will start as late as possible and stop as
soon as possible.</p></td></tr></tbody></table>
</div></div><br class="table-break">
<p>Configuring a JCA-based listener container with the "jms" schema support is very similar.</p>
<pre class="programlisting"><span class="hl-tag">&lt;jms:jca-listener-container</span> <span class="hl-attribute">resource-adapter</span>=<span class="hl-value">"myResourceAdapter"</span>
        <span class="hl-attribute">destination-resolver</span>=<span class="hl-value">"myDestinationResolver"</span>
        <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"myTransactionManager"</span>
        <span class="hl-attribute">concurrency</span>=<span class="hl-value">"10"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;jms:listener</span> <span class="hl-attribute">destination</span>=<span class="hl-value">"queue.orders"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myMessageListener"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/jms:jca-listener-container&gt;</span></pre>
<p>The available configuration options for the JCA variant are described in the following
table:</p>
<div class="table"><a name="jms-namespace-jca-listener-container-tbl" href="#jms-namespace-jca-listener-container-tbl"></a><p class="title"><b>Table&nbsp;24.3.&nbsp;Attributes of the JMS &lt;jca-listener-container/&gt; element</b></p><div class="table-contents">
<table summary="Attributes of the JMS <jca-listener-container/&gt; element" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>factory-id</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Exposes the settings defined by this element as a <code class="literal">JmsListenerContainerFactory</code>
with the specified id so that they can be reused with other endpoints.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>resource-adapter</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to the JCA <code class="literal">ResourceAdapter</code> bean (the default bean name is
<code class="literal">'resourceAdapter'</code>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>activation-spec-factory</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to the <code class="literal">JmsActivationSpecFactory</code>. The default is to autodetect the JMS
provider and its <code class="literal">ActivationSpec</code> class (see <code class="literal">DefaultJmsActivationSpecFactory</code>)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>destination-resolver</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to the <code class="literal">DestinationResolver</code> strategy for resolving JMS <code class="literal">Destinations</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>message-converter</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to the <code class="literal">MessageConverter</code> strategy for converting JMS Messages to listener
method arguments. Default is a <code class="literal">SimpleMessageConverter</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>destination-type</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The JMS destination type for this listener: <code class="literal">queue</code>, <code class="literal">topic</code>, <code class="literal">durableTopic</code>, <code class="literal">sharedTopic</code>
or <code class="literal">sharedDurableTopic</code>. This enables potentially the <code class="literal">pubSubDomain</code>, <code class="literal">subscriptionDurable</code>
and <code class="literal">subscriptionShared</code> properties of the container. The default is <code class="literal">queue</code> (i.e. disabling
those 3 properties).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>client-id</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The JMS client id for this listener container. Needs to be specified when using
durable subscriptions.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>acknowledge</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The native JMS acknowledge mode: <code class="literal">auto</code>, <code class="literal">client</code>, <code class="literal">dups-ok</code> or <code class="literal">transacted</code>. A value
of <code class="literal">transacted</code> activates a locally transacted <code class="literal">Session</code>. As an alternative, specify
the <code class="literal">transaction-manager</code> attribute described below. Default is <code class="literal">auto</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>transaction-manager</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A reference to a Spring <code class="literal">JtaTransactionManager</code> or a
<code class="literal">javax.transaction.TransactionManager</code> for kicking off an XA transaction for each
incoming message. If not specified, native acknowledging will be used (see the
"acknowledge" attribute).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>concurrency</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The number of concurrent sessions/consumers to start for each listener. Can either be
a simple number indicating the maximum number (e.g. "5") or a range indicating the
lower as well as the upper limit (e.g. "3-5"). Note that a specified minimum is just a
hint and will typically be ignored at runtime when using a JCA listener container.
Default is 1.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>prefetch</p></td><td style="" align="left" valign="top"><p>The maximum number of messages to load into a single session. Note that raising this
number might lead to starvation of concurrent consumers!</p></td></tr></tbody></table>
</div></div><br class="table-break">
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ejb.html">이전</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration.html">위로</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="jmx.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">23.&nbsp;Enterprise JavaBeans (EJB) integration&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">홈</a></td><td width="40%" align="right" valign="top">&nbsp;25.&nbsp;JMX</td></tr></table></div> 
</body>
</html>