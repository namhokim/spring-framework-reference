<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>7.&nbsp;검증, 데이터 바인딩, 타입 변환</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="스프링 프레임워크 레퍼런스 문서"><link rel="up" href="spring-core.html" title="III부.&nbsp;핵심 기술들"><link rel="prev" href="resources.html" title="6.&nbsp;리소스들"><link rel="next" href="expressions.html" title="8.&nbsp;스프링 표현식 언어 (SpEL)"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.&nbsp;검증, 데이터 바인딩, 타입 변환</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="resources.html">이전</a>&nbsp;</td><th width="60%" align="center">III부.&nbsp;핵심 기술들</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="expressions.html">다음</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="validation" href="#validation"></a>7.&nbsp;검증, 데이터 바인딩, 타입 변환</h2></div></div></div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-introduction" href="#validation-introduction"></a>7.1&nbsp;Introduction</h2></div></div></div>
<div class="sidebar"><div class="titlepage"><div><div><p class="title"><b>JSR-303/JSR-349 Bean Validation</b></p></div></div></div>
<p>Spring Framework 4.0 supports Bean Validation 1.0 (JSR-303) and Bean Validation 1.1
(JSR-349) in terms of setup support, also adapting it to Spring&#8217;s <code class="literal">Validator</code> interface.</p>
<p>An application can choose to enable Bean Validation once globally, as described in
<a class="xref" href="validation.html#validation-beanvalidation" title="7.8&nbsp;Spring Validation">Section&nbsp;7.8, &#8220;Spring Validation&#8221;</a>, and use it exclusively for all validation needs.</p>
<p>An application can also register additional Spring <code class="literal">Validator</code> instances per
<code class="literal">DataBinder</code> instance, as described in <a class="xref" href="validation.html#validation-binder" title="7.8.3&nbsp;Configuring a DataBinder">Section&nbsp;7.8.3, &#8220;Configuring a DataBinder&#8221;</a>. This may be useful for
plugging in validation logic without the use of annotations.</p>
</div>
<p>There are pros and cons for considering validation as business logic, and Spring offers
a design for validation (and data binding) that does not exclude either one of them.
Specifically validation should not be tied to the web tier, should be easy to localize
and it should be possible to plug in any validator available. Considering the above,
Spring has come up with a <code class="literal">Validator</code> interface that is both basic ands eminently usable
in every layer of an application.</p>
<p>Data binding is useful for allowing user input to be dynamically bound to the domain
model of an application (or whatever objects you use to process user input). Spring
provides the so-called <code class="literal">DataBinder</code> to do exactly that. The <code class="literal">Validator</code> and the
<code class="literal">DataBinder</code> make up the <code class="literal">validation</code> package, which is primarily used in but not
limited to the MVC framework.</p>
<p>The <code class="literal">BeanWrapper</code> is a fundamental concept in the Spring Framework and is used in a lot
of places. However, you probably will not have the need to use the <code class="literal">BeanWrapper</code>
directly. Because this is reference documentation however, we felt that some explanation
might be in order. We will explain the <code class="literal">BeanWrapper</code> in this chapter since, if you were
going to use it at all, you would most likely do so when trying to bind data to objects.</p>
<p>Spring&#8217;s DataBinder and the lower-level BeanWrapper both use PropertyEditors to parse
and format property values. The <code class="literal">PropertyEditor</code> concept is part of the JavaBeans
specification, and is also explained in this chapter. Spring 3 introduces a
"core.convert" package that provides a general type conversion facility, as well as a
higher-level "format" package for formatting UI field values. These new packages may be
used as simpler alternatives to PropertyEditors, and will also be discussed in this
chapter.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validator" href="#validator"></a>7.2&nbsp;Validation using Spring&#8217;s Validator interface</h2></div></div></div>
<p>Spring features a <code class="literal">Validator</code> interface that you can use to validate objects. The
<code class="literal">Validator</code> interface works using an <code class="literal">Errors</code> object so that while validating,
validators can report validation failures to the <code class="literal">Errors</code> object.</p>
<p>Let&#8217;s consider a small data object:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {

    <span class="hl-keyword">private</span> String name;
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> age;

    <span class="hl-comment">// the usual getters and setters...</span>
}</pre>
<p>We&#8217;re going to provide validation behavior for the <code class="literal">Person</code> class by implementing the
following two methods of the <code class="literal">org.springframework.validation.Validator</code> interface:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">supports(Class)</code> - Can this <code class="literal">Validator</code> validate instances of the supplied <code class="literal">Class</code>?
</li><li class="listitem">
<code class="literal">validate(Object, org.springframework.validation.Errors)</code> - validates the given object
and in case of validation errors, registers those with the given <code class="literal">Errors</code> object
</li></ul></div>
<p>Implementing a <code class="literal">Validator</code> is fairly straightforward, especially when you know of the
<code class="literal">ValidationUtils</code> helper class that the Spring Framework also provides.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PersonValidator <span class="hl-keyword">implements</span> Validator {

    <strong class="hl-tag" style="color: blue">/**
     * This Validator validates *just* Person instances
     */</strong>
    <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> supports(Class clazz) {
        <span class="hl-keyword">return</span> Person.<span class="hl-keyword">class</span>.equals(clazz);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> validate(Object obj, Errors e) {
        ValidationUtils.rejectIfEmpty(e, <span class="hl-string">"name"</span>, <span class="hl-string">"name.empty"</span>);
        Person p = (Person) obj;
        <span class="hl-keyword">if</span> (p.getAge() &lt; <span class="hl-number">0</span>) {
            e.rejectValue(<span class="hl-string">"age"</span>, <span class="hl-string">"negativevalue"</span>);
        } <span class="hl-keyword">else</span> <span class="hl-keyword">if</span> (p.getAge() &gt; <span class="hl-number">110</span>) {
            e.rejectValue(<span class="hl-string">"age"</span>, <span class="hl-string">"too.darn.old"</span>);
        }
    }
}</pre>
<p>As you can see, the <code class="literal">static</code> <code class="literal">rejectIfEmpty(..)</code> method on the <code class="literal">ValidationUtils</code> class
is used to reject the <code class="literal">'name'</code> property if it is <code class="literal">null</code> or the empty string. Have a look
at the <code class="literal">ValidationUtils</code> javadocs to see what functionality it provides besides the
example shown previously.</p>
<p>While it is certainly possible to implement a single <code class="literal">Validator</code> class to validate each
of the nested objects in a rich object, it may be better to encapsulate the validation
logic for each nested class of object in its own <code class="literal">Validator</code> implementation. A simple
example of a <span class="emphasis"><em>'rich'</em></span> object would be a <code class="literal">Customer</code> that is composed of two <code class="literal">String</code>
properties (a first and second name) and a complex <code class="literal">Address</code> object. <code class="literal">Address</code> objects
may be used independently of <code class="literal">Customer</code> objects, and so a distinct <code class="literal">AddressValidator</code>
has been implemented. If you want your <code class="literal">CustomerValidator</code> to reuse the logic contained
within the <code class="literal">AddressValidator</code> class without resorting to copy-and-paste, you can
dependency-inject or instantiate an <code class="literal">AddressValidator</code> within your <code class="literal">CustomerValidator</code>,
and use it like so:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomerValidator <span class="hl-keyword">implements</span> Validator {

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> Validator addressValidator;

    <span class="hl-keyword">public</span> CustomerValidator(Validator addressValidator) {
        <span class="hl-keyword">if</span> (addressValidator == null) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(<span class="hl-string">"The supplied [Validator] is "</span> +
                <span class="hl-string">"required and must not be null."</span>);
        }
        <span class="hl-keyword">if</span> (!addressValidator.supports(Address.<span class="hl-keyword">class</span>)) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(<span class="hl-string">"The supplied [Validator] must "</span> +
                support the validation of [Address] instances.<span class="hl-string">");
</span>        }
        <span class="hl-keyword">this</span>.addressValidator = addressValidator;
    }

    <strong class="hl-tag" style="color: blue">/**
     * This Validator validates Customer instances, and any subclasses of Customer too
     */</strong>
    <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> supports(Class clazz) {
        <span class="hl-keyword">return</span> Customer.<span class="hl-keyword">class</span>.isAssignableFrom(clazz);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> validate(Object target, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="hl-string">"firstName"</span>, <span class="hl-string">"field.required"</span>);
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="hl-string">"surname"</span>, <span class="hl-string">"field.required"</span>);
        Customer customer = (Customer) target;
        <span class="hl-keyword">try</span> {
            errors.pushNestedPath(<span class="hl-string">"address"</span>);
            ValidationUtils.invokeValidator(<span class="hl-keyword">this</span>.addressValidator, customer.getAddress(), errors);
        } <span class="hl-keyword">finally</span> {
            errors.popNestedPath();
        }
    }
}</pre>
<p>Validation errors are reported to the <code class="literal">Errors</code> object passed to the validator. In case
of Spring Web MVC you can use <code class="literal">&lt;spring:bind/&gt;</code> tag to inspect the error messages, but of
course you can also inspect the errors object yourself. More information about the
methods it offers can be found in the javadocs.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-conversion" href="#validation-conversion"></a>7.3&nbsp;Resolving codes to error messages</h2></div></div></div>
<p>We&#8217;ve talked about databinding and validation. Outputting messages corresponding to
validation errors is the last thing we need to discuss. In the example we&#8217;ve shown
above, we rejected the <code class="literal">name</code> and the <code class="literal">age</code> field. If we&#8217;re going to output the error
messages by using a <code class="literal">MessageSource</code>, we will do so using the error code we&#8217;ve given when
rejecting the field (<span class="emphasis"><em>name</em></span> and <span class="emphasis"><em>age</em></span> in this case). When you call (either directly, or
indirectly, using for example the <code class="literal">ValidationUtils</code> class) <code class="literal">rejectValue</code> or one of the
other <code class="literal">reject</code> methods from the <code class="literal">Errors</code> interface, the underlying implementation will
not only register the code you&#8217;ve passed in, but also a number of additional error
codes. What error codes it registers is determined by the <code class="literal">MessageCodesResolver</code> that is
used. By default, the <code class="literal">DefaultMessageCodesResolver</code> is used, which for example not only
registers a message with the code you gave, but also messages that include the field
name you passed to the reject method. So in case you reject a field using
<code class="literal">rejectValue("age", "too.darn.old")</code>, apart from the <code class="literal">too.darn.old</code> code, Spring will
also register <code class="literal">too.darn.old.age</code> and <code class="literal">too.darn.old.age.int</code> (so the first will include
the field name and the second will include the type of the field); this is done as a
convenience to aid developers in targeting error messages and suchlike.</p>
<p>More information on the <code class="literal">MessageCodesResolver</code> and the default strategy can be found
online in the javadocs of
<a class="ulink" href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/MessageCodesResolver.html" target="_top"><code class="literal">MessageCodesResolver</code></a>
and
<a class="ulink" href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html" target="_top"><code class="literal">DefaultMessageCodesResolver</code></a>,
respectively.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-beans" href="#beans-beans"></a>7.4&nbsp;Bean manipulation and the BeanWrapper</h2></div></div></div>
<p>The <code class="literal">org.springframework.beans</code> package adheres to the JavaBeans standard provided by
Oracle. A JavaBean is simply a class with a default no-argument constructor, which follows
a naming convention where (by way of an example) a property named <code class="literal">bingoMadness</code> would
have a setter method <code class="literal">setBingoMadness(..)</code> and a getter method <code class="literal">getBingoMadness()</code>. For
more information about JavaBeans and the specification, please refer to Oracle&#8217;s website (
<a class="ulink" href="http://docs.oracle.com/javase/6/docs/api/java/beans/package-summary.html" target="_top">javabeans</a>).</p>
<p>One quite important class in the beans package is the <code class="literal">BeanWrapper</code> interface and its
corresponding implementation ( <code class="literal">BeanWrapperImpl</code>). As quoted from the javadocs, the
<code class="literal">BeanWrapper</code> offers functionality to set and get property values (individually or in
bulk), get property descriptors, and to query properties to determine if they are
readable or writable. Also, the <code class="literal">BeanWrapper</code> offers support for nested properties,
enabling the setting of properties on sub-properties to an unlimited depth. Then, the
<code class="literal">BeanWrapper</code> supports the ability to add standard JavaBeans <code class="literal">PropertyChangeListeners</code>
and <code class="literal">VetoableChangeListeners</code>, without the need for supporting code in the target class.
Last but not least, the <code class="literal">BeanWrapper</code> provides support for the setting of indexed
properties. The <code class="literal">BeanWrapper</code> usually isn&#8217;t used by application code directly, but by
the <code class="literal">DataBinder</code> and the <code class="literal">BeanFactory</code>.</p>
<p>The way the <code class="literal">BeanWrapper</code> works is partly indicated by its name: <span class="emphasis"><em>it wraps a bean</em></span> to
perform actions on that bean, like setting and retrieving properties.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-conventions" href="#beans-beans-conventions"></a>7.4.1&nbsp;Setting and getting basic and nested properties</h3></div></div></div>
<p>Setting and getting properties is done using the <code class="literal">setPropertyValue(s)</code> and
<code class="literal">getPropertyValue(s)</code> methods that both come with a couple of overloaded variants.
They&#8217;re all described in more detail in the javadocs Spring comes with. What&#8217;s important
to know is that there are a couple of conventions for indicating properties of an
object. A couple of examples:</p>
<div class="table"><a name="beans-beans-conventions-properties-tbl" href="#beans-beans-conventions-properties-tbl"></a><p class="title"><b>Table&nbsp;7.1.&nbsp;Examples of properties</b></p><div class="table-contents">
<table summary="Examples of properties" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Expression</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Explanation</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">name</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Indicates the property <code class="literal">name</code> corresponding to the methods <code class="literal">getName()</code> or <code class="literal">isName()</code>
and <code class="literal">setName(..)</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">account.name</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Indicates the nested property <code class="literal">name</code> of the property <code class="literal">account</code> corresponding e.g. to
the methods <code class="literal">getAccount().setName()</code> or <code class="literal">getAccount().getName()</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">account[2]</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Indicates the <span class="emphasis"><em>third</em></span> element of the indexed property <code class="literal">account</code>. Indexed properties
can be of type <code class="literal">array</code>, <code class="literal">list</code> or other <span class="emphasis"><em>naturally ordered</em></span> collection</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">account[COMPANYNAME]</code></p></td><td style="" align="left" valign="top"><p>Indicates the value of the map entry indexed by the key <span class="emphasis"><em>COMPANYNAME</em></span> of the Map
property <code class="literal">account</code></p></td></tr></tbody></table>
</div></div><br class="table-break">
<p>Below you&#8217;ll find some examples of working with the <code class="literal">BeanWrapper</code> to get and set
properties.</p>
<p><span class="emphasis"><em>(This next section is not vitally important to you if you&#8217;re not planning to work with
the <code class="literal">BeanWrapper</code> directly. If you&#8217;re just using the <code class="literal">DataBinder</code> and the <code class="literal">BeanFactory</code>
and their out-of-the-box implementation, you should skip ahead to the section about
<code class="literal">PropertyEditors</code>.)</em></span></p>
<p>Consider the following two classes:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Company {

    <span class="hl-keyword">private</span> String name;
    <span class="hl-keyword">private</span> Employee managingDirector;

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) {
        <span class="hl-keyword">this</span>.name = name;
    }

    <span class="hl-keyword">public</span> Employee getManagingDirector() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.managingDirector;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setManagingDirector(Employee managingDirector) {
        <span class="hl-keyword">this</span>.managingDirector = managingDirector;
    }
}</pre>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Employee {

    <span class="hl-keyword">private</span> String name;

    <span class="hl-keyword">private</span> <span class="hl-keyword">float</span> salary;

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) {
        <span class="hl-keyword">this</span>.name = name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getSalary() {
        <span class="hl-keyword">return</span> salary;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSalary(<span class="hl-keyword">float</span> salary) {
        <span class="hl-keyword">this</span>.salary = salary;
    }
}</pre>
<p>The following code snippets show some examples of how to retrieve and manipulate some of
the properties of instantiated <code class="literal">Companies</code> and <code class="literal">Employees</code>:</p>
<pre class="programlisting">BeanWrapper company = BeanWrapperImpl(<span class="hl-keyword">new</span> Company());
<span class="hl-comment">// setting the company name..</span>
company.setPropertyValue(<span class="hl-string">"name"</span>, <span class="hl-string">"Some Company Inc."</span>);
<span class="hl-comment">// ... can also be done like this:</span>
PropertyValue value = <span class="hl-keyword">new</span> PropertyValue(<span class="hl-string">"name"</span>, <span class="hl-string">"Some Company Inc."</span>);
company.setPropertyValue(value);

<span class="hl-comment">// ok, let's create the director and tie it to the company:</span>
BeanWrapper jim = BeanWrapperImpl(<span class="hl-keyword">new</span> Employee());
jim.setPropertyValue(<span class="hl-string">"name"</span>, <span class="hl-string">"Jim Stravinsky"</span>);
company.setPropertyValue(<span class="hl-string">"managingDirector"</span>, jim.getWrappedInstance());

<span class="hl-comment">// retrieving the salary of the managingDirector through the company</span>
Float salary = (Float) company.getPropertyValue(<span class="hl-string">"managingDirector.salary"</span>);</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-conversion" href="#beans-beans-conversion"></a>7.4.2&nbsp;Built-in PropertyEditor implementations</h3></div></div></div>
<p>Spring uses the concept of <code class="literal">PropertyEditors</code> to effect the conversion between an
<code class="literal">Object</code> and a <code class="literal">String</code>. If you think about it, it sometimes might be handy to be able
to represent properties in a different way than the object itself. For example, a <code class="literal">Date</code>
can be represented in a human readable way (as the <code class="literal">String</code> ' <code class="literal">2007-14-09</code>'), while
we&#8217;re still able to convert the human readable form back to the original date (or even
better: convert any date entered in a human readable form, back to <code class="literal">Date</code> objects). This
behavior can be achieved by <span class="emphasis"><em>registering custom editors</em></span>, of type
<code class="literal">java.beans.PropertyEditor</code>. Registering custom editors on a <code class="literal">BeanWrapper</code> or
alternately in a specific IoC container as mentioned in the previous chapter, gives it
the knowledge of how to convert properties to the desired type. Read more about
<code class="literal">PropertyEditors</code> in the javadocs of the <code class="literal">java.beans</code> package provided by Oracle.</p>
<p>A couple of examples where property editing is used in Spring:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="emphasis"><em>setting properties on beans</em></span> is done using <code class="literal">PropertyEditors</code>. When mentioning
<code class="literal">java.lang.String</code> as the value of a property of some bean you&#8217;re declaring in XML
file, Spring will (if the setter of the corresponding property has a
<code class="literal">Class</code>-parameter) use the <code class="literal">ClassEditor</code> to try to resolve the parameter to a <code class="literal">Class</code>
object.
</li><li class="listitem">
<span class="emphasis"><em>parsing HTTP request parameters</em></span> in Spring&#8217;s MVC framework is done using all kinds
of <code class="literal">PropertyEditors</code> that you can manually bind in all subclasses of the
<code class="literal">CommandController</code>.
</li></ul></div>
<p>Spring has a number of built-in <code class="literal">PropertyEditors</code> to make life easy. Each of those is
listed below and they are all located in the <code class="literal">org.springframework.beans.propertyeditors</code>
package. Most, but not all (as indicated below), are registered by default by
<code class="literal">BeanWrapperImpl</code>. Where the property editor is configurable in some fashion, you can of
course still register your own variant to override the default one:</p>
<div class="table"><a name="beans-beans-property-editors-tbl" href="#beans-beans-property-editors-tbl"></a><p class="title"><b>Table&nbsp;7.2.&nbsp;Built-in PropertyEditors</b></p><div class="table-contents">
<table summary="Built-in PropertyEditors" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Class</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Explanation</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">ByteArrayPropertyEditor</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Editor for byte arrays. Strings will simply be converted to their corresponding byte
representations. Registered by default by <code class="literal">BeanWrapperImpl</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">ClassEditor</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Parses Strings representing classes to actual classes and the other way around. When a
class is not found, an <code class="literal">IllegalArgumentException</code> is thrown. Registered by default by
<code class="literal">BeanWrapperImpl</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">CustomBooleanEditor</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Customizable property editor for <code class="literal">Boolean</code> properties. Registered by default by
<code class="literal">BeanWrapperImpl</code>, but, can be overridden by registering custom instance of it as
custom editor.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">CustomCollectionEditor</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Property editor for Collections, converting any source <code class="literal">Collection</code> to a given target
<code class="literal">Collection</code> type.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">CustomDateEditor</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Customizable property editor for java.util.Date, supporting a custom DateFormat. NOT
registered by default. Must be user registered as needed with appropriate format.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">CustomNumberEditor</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Customizable property editor for any Number subclass like <code class="literal">Integer</code>, <code class="literal">Long</code>, <code class="literal">Float</code>,
<code class="literal">Double</code>. Registered by default by <code class="literal">BeanWrapperImpl</code>, but can be overridden by
registering custom instance of it as a custom editor.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">FileEditor</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Capable of resolving Strings to <code class="literal">java.io.File</code> objects. Registered by default by
<code class="literal">BeanWrapperImpl</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">InputStreamEditor</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>One-way property editor, capable of taking a text string and producing (via an
intermediate <code class="literal">ResourceEditor</code> and <code class="literal">Resource</code>) an <code class="literal">InputStream</code>, so <code class="literal">InputStream</code>
properties may be directly set as Strings. Note that the default usage will not close
the <code class="literal">InputStream</code> for you! Registered by default by <code class="literal">BeanWrapperImpl</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">LocaleEditor</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Capable of resolving Strings to <code class="literal">Locale</code> objects and vice versa (the String format is
<span class="emphasis"><em><span class="language">[country]</span></em></span>[variant], which is the same thing the toString() method of
Locale provides). Registered by default by <code class="literal">BeanWrapperImpl</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">PatternEditor</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Capable of resolving Strings to <code class="literal">java.util.regex.Pattern</code> objects and vice versa.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">PropertiesEditor</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Capable of converting Strings (formatted using the format as defined in the javadocs
of the <code class="literal">java.util.Properties</code> class) to <code class="literal">Properties</code> objects. Registered by default
by <code class="literal">BeanWrapperImpl</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">StringTrimmerEditor</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Property editor that trims Strings. Optionally allows transforming an empty string
into a <code class="literal">null</code> value. NOT registered by default; must be user registered as needed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">URLEditor</code></p></td><td style="" align="left" valign="top"><p>Capable of resolving a String representation of a URL to an actual <code class="literal">URL</code> object.
Registered by default by <code class="literal">BeanWrapperImpl</code>.</p></td></tr></tbody></table>
</div></div><br class="table-break">
<p>Spring uses the <code class="literal">java.beans.PropertyEditorManager</code> to set the search path for property
editors that might be needed. The search path also includes <code class="literal">sun.bean.editors</code>, which
includes <code class="literal">PropertyEditor</code> implementations for types such as <code class="literal">Font</code>, <code class="literal">Color</code>, and most of
the primitive types. Note also that the standard JavaBeans infrastructure will
automatically discover <code class="literal">PropertyEditor</code> classes (without you having to register them
explicitly) if they are in the same package as the class they handle, and have the same
name as that class, with <code class="literal">'Editor'</code> appended; for example, one could have the following
class and package structure, which would be sufficient for the <code class="literal">FooEditor</code> class to be
recognized and used as the <code class="literal">PropertyEditor</code> for <code class="literal">Foo</code>-typed properties.</p>
<pre class="literallayout">com
  chank
    pop
      Foo
      FooEditor // the PropertyEditor for the Foo class</pre>
<p>Note that you can also use the standard <code class="literal">BeanInfo</code> JavaBeans mechanism here as well
(described
<a class="ulink" href="http://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html" target="_top">in
not-amazing-detail here</a>). Find below an example of using the <code class="literal">BeanInfo</code> mechanism for
explicitly registering one or more <code class="literal">PropertyEditor</code> instances with the properties of an
associated class.</p>
<pre class="literallayout">com
  chank
    pop
      Foo
      FooBeanInfo // the BeanInfo for the Foo class</pre>
<p>Here is the Java source code for the referenced <code class="literal">FooBeanInfo</code> class. This would
associate a <code class="literal">CustomNumberEditor</code> with the <code class="literal">age</code> property of the <code class="literal">Foo</code> class.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FooBeanInfo <span class="hl-keyword">extends</span> SimpleBeanInfo {

    <span class="hl-keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() {
        <span class="hl-keyword">try</span> {
            <span class="hl-keyword">final</span> PropertyEditor numberPE = <span class="hl-keyword">new</span> CustomNumberEditor(Integer.<span class="hl-keyword">class</span>, true);
            PropertyDescriptor ageDescriptor = <span class="hl-keyword">new</span> PropertyDescriptor(<span class="hl-string">"age"</span>, Foo.<span class="hl-keyword">class</span>) {
                <span class="hl-keyword">public</span> PropertyEditor createPropertyEditor(Object bean) {
                    <span class="hl-keyword">return</span> numberPE;
                };
            };
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> PropertyDescriptor[] { ageDescriptor };
        }
        <span class="hl-keyword">catch</span> (IntrospectionException ex) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> Error(ex.toString());
        }
    }
}</pre>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="beans-beans-conversion-customeditor-registration" href="#beans-beans-conversion-customeditor-registration"></a>Registering additional custom PropertyEditors</h4></div></div></div>
<p>When setting bean properties as a string value, a Spring IoC container ultimately uses
standard JavaBeans <code class="literal">PropertyEditors</code> to convert these Strings to the complex type of the
property. Spring pre-registers a number of custom <code class="literal">PropertyEditors</code> (for example, to
convert a classname expressed as a string into a real <code class="literal">Class</code> object). Additionally,
Java&#8217;s standard JavaBeans <code class="literal">PropertyEditor</code> lookup mechanism allows a <code class="literal">PropertyEditor</code>
for a class simply to be named appropriately and placed in the same package as the class
it provides support for, to be found automatically.</p>
<p>If there is a need to register other custom <code class="literal">PropertyEditors</code>, there are several
mechanisms available. The most manual approach, which is not normally convenient or
recommended, is to simply use the <code class="literal">registerCustomEditor()</code> method of the
<code class="literal">ConfigurableBeanFactory</code> interface, assuming you have a <code class="literal">BeanFactory</code> reference.
Another, slightly more convenient, mechanism is to use a special bean factory
post-processor called <code class="literal">CustomEditorConfigurer</code>. Although bean factory post-processors
can be used with <code class="literal">BeanFactory</code> implementations, the <code class="literal">CustomEditorConfigurer</code> has a
nested property setup, so it is strongly recommended that it is used with the
<code class="literal">ApplicationContext</code>, where it may be deployed in similar fashion to any other bean, and
automatically detected and applied.</p>
<p>Note that all bean factories and application contexts automatically use a number of
built-in property editors, through their use of something called a <code class="literal">BeanWrapper</code> to
handle property conversions. The standard property editors that the <code class="literal">BeanWrapper</code>
registers are listed in <a class="link" href="validation.html#beans-beans-conversion" title="7.4.2&nbsp;Built-in PropertyEditor implementations">the previous section</a>. Additionally,
<code class="literal">ApplicationContexts</code> also override or add an additional number of editors to handle
resource lookups in a manner appropriate to the specific application context type.</p>
<p>Standard JavaBeans <code class="literal">PropertyEditor</code> instances are used to convert property values
expressed as strings to the actual complex type of the property.
<code class="literal">CustomEditorConfigurer</code>, a bean factory post-processor, may be used to conveniently add
support for additional <code class="literal">PropertyEditor</code> instances to an <code class="literal">ApplicationContext</code>.</p>
<p>Consider a user class <code class="literal">ExoticType</code>, and another class <code class="literal">DependsOnExoticType</code> which needs
<code class="literal">ExoticType</code> set as a property:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> example;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExoticType {

    <span class="hl-keyword">private</span> String name;

    <span class="hl-keyword">public</span> ExoticType(String name) {
        <span class="hl-keyword">this</span>.name = name;
    }
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DependsOnExoticType {

    <span class="hl-keyword">private</span> ExoticType type;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setType(ExoticType type) {
        <span class="hl-keyword">this</span>.type = type;
    }
}</pre>
<p>When things are properly set up, we want to be able to assign the type property as a
string, which a <code class="literal">PropertyEditor</code> will behind the scenes convert into an actual
<code class="literal">ExoticType</code> instance:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sample"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"example.DependsOnExoticType"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"type"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"aNameForExoticType"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>The <code class="literal">PropertyEditor</code> implementation could look similar to this:</p>
<pre class="programlisting"><span class="hl-comment">// converts string representation to ExoticType object</span>
<span class="hl-keyword">package</span> example;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExoticTypeEditor <span class="hl-keyword">extends</span> PropertyEditorSupport {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setAsText(String text) {
        setValue(<span class="hl-keyword">new</span> ExoticType(text.toUpperCase()));
    }
}</pre>
<p>Finally, we use <code class="literal">CustomEditorConfigurer</code> to register the new <code class="literal">PropertyEditor</code> with the
<code class="literal">ApplicationContext</code>, which will then be able to use it as needed:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.beans.factory.config.CustomEditorConfigurer"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"customEditors"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;map&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"example.ExoticType"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"example.ExoticTypeEditor"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/map&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="beans-beans-conversion-customeditor-registration-per" href="#beans-beans-conversion-customeditor-registration-per"></a>Using PropertyEditorRegistrars</h5></div></div></div>
<p>Another mechanism for registering property editors with the Spring container is to
create and use a <code class="literal">PropertyEditorRegistrar</code>. This interface is particularly useful when
you need to use the same set of property editors in several different situations: write
a corresponding registrar and reuse that in each case. <code class="literal">PropertyEditorRegistrars</code> work
in conjunction with an interface called <code class="literal">PropertyEditorRegistry</code>, an interface that is
implemented by the Spring <code class="literal">BeanWrapper</code> (and <code class="literal">DataBinder</code>). <code class="literal">PropertyEditorRegistrars</code>
are particularly convenient when used in conjunction with the <code class="literal">CustomEditorConfigurer</code>
(introduced <a class="link" href="validation.html#beans-beans-conversion-customeditor-registration" title="Registering additional custom PropertyEditors">here</a>), which exposes a
property called <code class="literal">setPropertyEditorRegistrars(..)</code>: <code class="literal">PropertyEditorRegistrars</code> added to a
<code class="literal">CustomEditorConfigurer</code> in this fashion can easily be shared with <code class="literal">DataBinder</code> and
Spring MVC <code class="literal">Controllers</code>. Furthermore, it avoids the need for synchronization on custom
editors: a <code class="literal">PropertyEditorRegistrar</code> is expected to create fresh <code class="literal">PropertyEditor</code>
instances for each bean creation attempt.</p>
<p>Using a <code class="literal">PropertyEditorRegistrar</code> is perhaps best illustrated with an example. First
off, you need to create your own <code class="literal">PropertyEditorRegistrar</code> implementation:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> com.foo.editors.spring;

<span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> CustomPropertyEditorRegistrar <span class="hl-keyword">implements</span> PropertyEditorRegistrar {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> registerCustomEditors(PropertyEditorRegistry registry) {

        <span class="hl-comment">// it is expected that new PropertyEditor instances are created</span>
        registry.registerCustomEditor(ExoticType.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> ExoticTypeEditor());

        <span class="hl-comment">// you could register as many custom property editors as are required here...</span>
    }
}</pre>
<p>See also the <code class="literal">org.springframework.beans.support.ResourceEditorRegistrar</code> for an example
<code class="literal">PropertyEditorRegistrar</code> implementation. Notice how in its implementation of the
<code class="literal">registerCustomEditors(..)</code> method it creates new instances of each property editor.</p>
<p>Next we configure a <code class="literal">CustomEditorConfigurer</code> and inject an instance of our
<code class="literal">CustomPropertyEditorRegistrar</code> into it:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.beans.factory.config.CustomEditorConfigurer"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"propertyEditorRegistrars"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;list&gt;</span>
            <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"customPropertyEditorRegistrar"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/list&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"customPropertyEditorRegistrar"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"com.foo.editors.spring.CustomPropertyEditorRegistrar"</span><span class="hl-tag">/&gt;</span></pre>
<p>Finally, and in a bit of a departure from the focus of this chapter, for those of you
using <a class="link" href="mvc.html" title="17.&nbsp;Web MVC framework">Spring&#8217;s MVC web framework</a>, using <code class="literal">PropertyEditorRegistrars</code> in
conjunction with data-binding <code class="literal">Controllers</code> (such as <code class="literal">SimpleFormController</code>) can be very
convenient. Find below an example of using a <code class="literal">PropertyEditorRegistrar</code> in the
implementation of an <code class="literal">initBinder(..)</code> method:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> RegisterUserController <span class="hl-keyword">extends</span> SimpleFormController {

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> PropertyEditorRegistrar customPropertyEditorRegistrar;

    <span class="hl-keyword">public</span> RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
        <span class="hl-keyword">this</span>.customPropertyEditorRegistrar = propertyEditorRegistrar;
    }

    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> initBinder(HttpServletRequest request,
            ServletRequestDataBinder binder) <span class="hl-keyword">throws</span> Exception {
        <span class="strong"><strong>this.customPropertyEditorRegistrar.registerCustomEditors(binder);</strong></span>
    }

    <span class="hl-comment">// other methods to do with registering a User</span>
}</pre>
<p>This style of <code class="literal">PropertyEditor</code> registration can lead to concise code (the implementation
of <code class="literal">initBinder(..)</code> is just one line long!), and allows common <code class="literal">PropertyEditor</code>
registration code to be encapsulated in a class and then shared amongst as many
<code class="literal">Controllers</code> as needed.</p>
</div>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-convert" href="#core-convert"></a>7.5&nbsp;Spring Type Conversion</h2></div></div></div>
<p>Spring 3 introduces a <code class="literal">core.convert</code> package that provides a general type conversion
system. The system defines an SPI to implement type conversion logic, as well as an API
to execute type conversions at runtime. Within a Spring container, this system can be
used as an alternative to PropertyEditors to convert externalized bean property value
strings to required property types. The public API may also be used anywhere in your
application where type conversion is needed.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="core-convert-Converter-API" href="#core-convert-Converter-API"></a>7.5.1&nbsp;Converter SPI</h3></div></div></div>
<p>The SPI to implement type conversion logic is simple and strongly typed:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.core.convert.converter;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Converter&lt;S, T&gt; {

    T convert(S source);

}</pre>
<p>To create your own converter, simply implement the interface above. Parameterize <code class="literal">S</code>
as the type you are converting from, and <code class="literal">T</code> as the type you are converting to. Such a
converter can also be applied transparently if a collection or array of <code class="literal">S</code> needs to be
converted to an array or collection of <code class="literal">T</code>, provided that a delegating array/collection
converter has been registered as well (which <code class="literal">DefaultConversionService</code> does by default).</p>
<p>For each call to <code class="literal">convert(S)</code>, the source argument is guaranteed to be NOT null. Your
Converter may throw any unchecked exception if conversion fails; specifically, an
<code class="literal">IllegalArgumentException</code> should be thrown to report an invalid source value.
Take care to ensure that your <code class="literal">Converter</code> implementation is thread-safe.</p>
<p>Several converter implementations are provided in the <code class="literal">core.convert.support</code> package as
a convenience. These include converters from Strings to Numbers and other common types.
Consider <code class="literal">StringToInteger</code> as an example for a typical <code class="literal">Converter</code> implementation:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.core.convert.support;

<span class="hl-keyword">final</span> <span class="hl-keyword">class</span> StringToInteger <span class="hl-keyword">implements</span> Converter&lt;String, Integer&gt; {

    <span class="hl-keyword">public</span> Integer convert(String source) {
        <span class="hl-keyword">return</span> Integer.valueOf(source);
    }

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="core-convert-ConverterFactory-SPI" href="#core-convert-ConverterFactory-SPI"></a>7.5.2&nbsp;ConverterFactory</h3></div></div></div>
<p>When you need to centralize the conversion logic for an entire class hierarchy, for
example, when converting from String to java.lang.Enum objects, implement
<code class="literal">ConverterFactory</code>:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.core.convert.converter;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ConverterFactory&lt;S, R&gt; {

    &lt;T <span class="hl-keyword">extends</span> R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);

}</pre>
<p>Parameterize S to be the type you are converting from and R to be the base type defining
the <span class="emphasis"><em>range</em></span> of classes you can convert to. Then implement getConverter(Class&lt;T&gt;),
where T is a subclass of R.</p>
<p>Consider the <code class="literal">StringToEnum</code> ConverterFactory as an example:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.core.convert.support;

<span class="hl-keyword">final</span> <span class="hl-keyword">class</span> StringToEnumConverterFactory <span class="hl-keyword">implements</span> ConverterFactory&lt;String, Enum&gt; {

    <span class="hl-keyword">public</span> &lt;T <span class="hl-keyword">extends</span> Enum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> StringToEnumConverter(targetType);
    }

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> StringToEnumConverter&lt;T <span class="hl-keyword">extends</span> Enum&gt; <span class="hl-keyword">implements</span> Converter&lt;String, T&gt; {

        <span class="hl-keyword">private</span> Class&lt;T&gt; enumType;

        <span class="hl-keyword">public</span> StringToEnumConverter(Class&lt;T&gt; enumType) {
            <span class="hl-keyword">this</span>.enumType = enumType;
        }

        <span class="hl-keyword">public</span> T convert(String source) {
            <span class="hl-keyword">return</span> (T) Enum.valueOf(<span class="hl-keyword">this</span>.enumType, source.trim());
        }
    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="core-convert-GenericConverter-SPI" href="#core-convert-GenericConverter-SPI"></a>7.5.3&nbsp;GenericConverter</h3></div></div></div>
<p>When you require a sophisticated Converter implementation, consider the GenericConverter
interface. With a more flexible but less strongly typed signature, a GenericConverter
supports converting between multiple source and target types. In addition, a
GenericConverter makes available source and target field context you can use when
implementing your conversion logic. Such context allows a type conversion to be driven
by a field annotation, or generic information declared on a field signature.</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.core.convert.converter;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> GenericConverter {

    <span class="hl-keyword">public</span> Set&lt;ConvertiblePair&gt; getConvertibleTypes();

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

}</pre>
<p>To implement a GenericConverter, have getConvertibleTypes() return the supported
source&#8594;target type pairs. Then implement convert(Object, TypeDescriptor,
TypeDescriptor) to implement your conversion logic. The source TypeDescriptor provides
access to the source field holding the value being converted. The target TypeDescriptor
provides access to the target field where the converted value will be set.</p>
<p>A good example of a GenericConverter is a converter that converts between a Java Array
and a Collection. Such an ArrayToCollectionConverter introspects the field that declares
the target Collection type to resolve the Collection&#8217;s element type. This allows each
element in the source array to be converted to the Collection element type before the
Collection is set on the target field.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Because GenericConverter is a more complex SPI interface, only use it when you need it.
Favor Converter or ConverterFactory for basic type conversion needs.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="core-convert-ConditionalGenericConverter-SPI" href="#core-convert-ConditionalGenericConverter-SPI"></a>ConditionalGenericConverter</h4></div></div></div>
<p>Sometimes you only want a Converter to execute if a specific condition holds true. For
example, you might only want to execute a Converter if a specific annotation is present
on the target field. Or you might only want to execute a Converter if a specific method,
such as static valueOf method, is defined on the target class.
ConditionalGenericConverter is an subinterface of GenericConverter that allows you to
define such custom matching criteria:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ConditionalGenericConverter <span class="hl-keyword">extends</span> GenericConverter {

    <span class="hl-keyword">boolean</span> matches(TypeDescriptor sourceType, TypeDescriptor targetType);

}</pre>
<p>A good example of a ConditionalGenericConverter is an EntityConverter that converts
between an persistent entity identifier and an entity reference. Such a EntityConverter
might only match if the target entity type declares a static finder method e.g.
findAccount(Long). You would perform such a finder method check in the implementation of
matches(TypeDescriptor, TypeDescriptor).</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="core-convert-ConversionService-API" href="#core-convert-ConversionService-API"></a>7.5.4&nbsp;ConversionService API</h3></div></div></div>
<p>The ConversionService defines a unified API for executing type conversion logic at
runtime. Converters are often executed behind this facade interface:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.core.convert;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ConversionService {

    <span class="hl-keyword">boolean</span> canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);

    &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType);

    <span class="hl-keyword">boolean</span> canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

}</pre>
<p>Most ConversionService implementations also implement <code class="literal">ConverterRegistry</code>, which
provides an SPI for registering converters. Internally, a ConversionService
implementation delegates to its registered converters to carry out type conversion logic.</p>
<p>A robust ConversionService implementation is provided in the <code class="literal">core.convert.support</code>
package. <code class="literal">GenericConversionService</code> is the general-purpose implementation suitable for
use in most environments. <code class="literal">ConversionServiceFactory</code> provides a convenient factory for
creating common ConversionService configurations.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="core-convert-Spring-config" href="#core-convert-Spring-config"></a>7.5.5&nbsp;Configuring a ConversionService</h3></div></div></div>
<p>A ConversionService is a stateless object designed to be instantiated at application
startup, then shared between multiple threads. In a Spring application, you typically
configure a ConversionService instance per Spring container (or ApplicationContext).
That ConversionService will be picked up by Spring and then used whenever a type
conversion needs to be performed by the framework. You may also inject this
ConversionService into any of your beans and invoke it directly.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>If no ConversionService is registered with Spring, the original PropertyEditor-based
system is used.</p>
</td></tr></table></div>
<p>To register a default ConversionService with Spring, add the following bean definition
with id <code class="literal">conversionService</code>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"conversionService"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.context.support.ConversionServiceFactoryBean"</span><span class="hl-tag">/&gt;</span></pre>
<p>A default ConversionService can convert between strings, numbers, enums, collections,
maps, and other common types. To supplement or override the default converters with your
own custom converter(s), set the <code class="literal">converters</code> property. Property values may implement
either of the Converter, ConverterFactory, or GenericConverter interfaces.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"conversionService"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.context.support.ConversionServiceFactoryBean"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"converters"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;set&gt;</span>
            <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"example.MyCustomConverter"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/set&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>It is also common to use a ConversionService within a Spring MVC application. See
<a class="xref" href="validation.html#format-configuring-formatting-mvc" title="7.6.5&nbsp;Configuring Formatting in Spring MVC">Section&nbsp;7.6.5, &#8220;Configuring Formatting in Spring MVC&#8221;</a> for details on use with <code class="literal">&lt;mvc:annotation-driven/&gt;</code>.</p>
<p>In certain situations you may wish to apply formatting during conversion. See
<a class="xref" href="validation.html#format-FormatterRegistry-SPI" title="7.6.3&nbsp;FormatterRegistry SPI">Section&nbsp;7.6.3, &#8220;FormatterRegistry SPI&#8221;</a> for details on using
<code class="literal">FormattingConversionServiceFactoryBean</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="core-convert-programmatic-usage" href="#core-convert-programmatic-usage"></a>7.5.6&nbsp;Using a ConversionService programmatically</h3></div></div></div>
<p>To work with a ConversionService instance programmatically, simply inject a reference to
it like you would for any other bean:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Service</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">public</span> MyService(ConversionService conversionService) {
        <span class="hl-keyword">this</span>.conversionService = conversionService;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doIt() {
        <span class="hl-keyword">this</span>.conversionService.convert(...)
    }
}</pre>
<p>For most use cases, the <code class="literal">convert</code> method specifying the <span class="emphasis"><em>targetType</em></span> can be used but it
will not work with more complex types such as a collection of a parameterized element.
If you want to convert a <code class="literal">List</code> of <code class="literal">Integer</code> to a <code class="literal">List</code> of <code class="literal">String</code> programmatically,
for instance, you need to provide a formal definition of the source and target types.</p>
<p>Fortunately, <code class="literal">TypeDescriptor</code> provides various options to make that straightforward:</p>
<pre class="programlisting">DefaultConversionService cs = <span class="hl-keyword">new</span> DefaultConversionService();

List&lt;Integer&gt; input = ....
cs.convert(input,
    TypeDescriptor.forObject(input), <span class="hl-comment">// List&lt;Integer&gt; type descriptor</span>
    TypeDescriptor.collection(List.<span class="hl-keyword">class</span>, TypeDescriptor.valueOf(String.<span class="hl-keyword">class</span>)));</pre>
<p>Note that <code class="literal">DefaultConversionService</code> registers converters automatically which are
appropriate for most environments. This includes collection converters, scalar
converters, and also basic <code class="literal">Object</code> to <code class="literal">String</code> converters. The same converters can
be registered with any <code class="literal">ConverterRegistry</code> using the <span class="emphasis"><em>static</em></span> <code class="literal">addDefaultConverters</code>
method on the <code class="literal">DefaultConversionService</code> class.</p>
<p>Converters for value types will be reused for arrays and collections, so there is
no need to create a specific converter to convert from a <code class="literal">Collection</code> of <code class="literal">S</code> to a
<code class="literal">Collection</code> of <code class="literal">T</code>, assuming that standard collection handling is appropriate.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="format" href="#format"></a>7.6&nbsp;Spring Field Formatting</h2></div></div></div>
<p>As discussed in the previous section, <a class="link" href="validation.html#core-convert" title="7.5&nbsp;Spring Type Conversion"><code class="literal">core.convert</code></a> is a
general-purpose type conversion system. It provides a unified ConversionService API as
well as a strongly-typed Converter SPI for implementing conversion logic from one type
to another. A Spring Container uses this system to bind bean property values. In
addition, both the Spring Expression Language (SpEL) and DataBinder use this system to
bind field values. For example, when SpEL needs to coerce a <code class="literal">Short</code> to a <code class="literal">Long</code> to
complete an <code class="literal">expression.setValue(Object bean, Object value)</code> attempt, the core.convert
system performs the coercion.</p>
<p>Now consider the type conversion requirements of a typical client environment such as a
web or desktop application. In such environments, you typically convert <span class="emphasis"><em>from String</em></span>
to support the client postback process, as well as back <span class="emphasis"><em>to String</em></span> to support the
view rendering process. In addition, you often need to localize String values. The more
general <span class="emphasis"><em>core.convert</em></span> Converter SPI does not address such <span class="emphasis"><em>formatting</em></span> requirements
directly. To directly address them, Spring 3 introduces a convenient Formatter SPI that
provides a simple and robust alternative to PropertyEditors for client environments.</p>
<p>In general, use the Converter SPI when you need to implement general-purpose type
conversion logic; for example, for converting between a java.util.Date and and
java.lang.Long. Use the Formatter SPI when you&#8217;re working in a client environment, such
as a web application, and need to parse and print localized field values. The
ConversionService provides a unified type conversion API for both SPIs.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="format-Formatter-SPI" href="#format-Formatter-SPI"></a>7.6.1&nbsp;Formatter SPI</h3></div></div></div>
<p>The Formatter SPI to implement field formatting logic is simple and strongly typed:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.format;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Formatter&lt;T&gt; <span class="hl-keyword">extends</span> Printer&lt;T&gt;, Parser&lt;T&gt; {
}</pre>
<p>Where Formatter extends from the Printer and Parser building-block interfaces:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Printer&lt;T&gt; {
    String print(T fieldValue, Locale locale);
}</pre>
<pre class="programlisting"><span class="hl-keyword">import</span> java.text.ParseException;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Parser&lt;T&gt; {
    T parse(String clientValue, Locale locale) <span class="hl-keyword">throws</span> ParseException;
}</pre>
<p>To create your own Formatter, simply implement the Formatter interface above.
Parameterize T to be the type of object you wish to format, for example,
<code class="literal">java.util.Date</code>. Implement the <code class="literal">print()</code> operation to print an instance of T for
display in the client locale. Implement the <code class="literal">parse()</code> operation to parse an instance of
T from the formatted representation returned from the client locale. Your Formatter
should throw a ParseException or IllegalArgumentException if a parse attempt fails. Take
care to ensure your Formatter implementation is thread-safe.</p>
<p>Several Formatter implementations are provided in <code class="literal">format</code> subpackages as a convenience.
The <code class="literal">number</code> package provides a <code class="literal">NumberFormatter</code>, <code class="literal">CurrencyFormatter</code>, and
<code class="literal">PercentFormatter</code> to format <code class="literal">java.lang.Number</code> objects using a <code class="literal">java.text.NumberFormat</code>.
The <code class="literal">datetime</code> package provides a <code class="literal">DateFormatter</code> to format <code class="literal">java.util.Date</code> objects with
a <code class="literal">java.text.DateFormat</code>. The <code class="literal">datetime.joda</code> package provides comprehensive datetime
formatting support based on the <a class="ulink" href="http://joda-time.sourceforge.net" target="_top">Joda Time library</a>.</p>
<p>Consider <code class="literal">DateFormatter</code> as an example <code class="literal">Formatter</code> implementation:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.format.datetime;

<span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> DateFormatter <span class="hl-keyword">implements</span> Formatter&lt;Date&gt; {

    <span class="hl-keyword">private</span> String pattern;

    <span class="hl-keyword">public</span> DateFormatter(String pattern) {
        <span class="hl-keyword">this</span>.pattern = pattern;
    }

    <span class="hl-keyword">public</span> String print(Date date, Locale locale) {
        <span class="hl-keyword">if</span> (date == null) {
            <span class="hl-keyword">return</span> <span class="hl-string">""</span>;
        }
        <span class="hl-keyword">return</span> getDateFormat(locale).format(date);
    }

    <span class="hl-keyword">public</span> Date parse(String formatted, Locale locale) <span class="hl-keyword">throws</span> ParseException {
        <span class="hl-keyword">if</span> (formatted.length() == <span class="hl-number">0</span>) {
            <span class="hl-keyword">return</span> null;
        }
        <span class="hl-keyword">return</span> getDateFormat(locale).parse(formatted);
    }

    <span class="hl-keyword">protected</span> DateFormat getDateFormat(Locale locale) {
        DateFormat dateFormat = <span class="hl-keyword">new</span> SimpleDateFormat(<span class="hl-keyword">this</span>.pattern, locale);
        dateFormat.setLenient(false);
        <span class="hl-keyword">return</span> dateFormat;
    }

}</pre>
<p>The Spring team welcomes community-driven <code class="literal">Formatter</code> contributions; see
<a class="ulink" href="https://jira.spring.io/browse/SPR" target="_top">jira.spring.io</a> to contribute.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="format-CustomFormatAnnotations" href="#format-CustomFormatAnnotations"></a>7.6.2&nbsp;Annotation-driven Formatting</h3></div></div></div>
<p>As you will see, field formatting can be configured by field type or annotation. To bind
an Annotation to a formatter, implement AnnotationFormatterFactory:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.format;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> AnnotationFormatterFactory&lt;A <span class="hl-keyword">extends</span> Annotation&gt; {

    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();

    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);

    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);

}</pre>
<p>Parameterize A to be the field annotationType you wish to associate formatting logic
with, for example <code class="literal">org.springframework.format.annotation.DateTimeFormat</code>. Have
<code class="literal">getFieldTypes()</code> return the types of fields the annotation may be used on. Have
<code class="literal">getPrinter()</code> return a Printer to print the value of an annotated field. Have
<code class="literal">getParser()</code> return a Parser to parse a clientValue for an annotated field.</p>
<p>The example AnnotationFormatterFactory implementation below binds the @NumberFormat
Annotation to a formatter. This annotation allows either a number style or pattern to be
specified:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> NumberFormatAnnotationFormatterFactory
        <span class="hl-keyword">implements</span> AnnotationFormatterFactory&lt;NumberFormat&gt; {

    <span class="hl-keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;(asList(<span class="hl-keyword">new</span> Class&lt;?&gt;[] {
            Short.<span class="hl-keyword">class</span>, Integer.<span class="hl-keyword">class</span>, Long.<span class="hl-keyword">class</span>, Float.<span class="hl-keyword">class</span>,
            Double.<span class="hl-keyword">class</span>, BigDecimal.<span class="hl-keyword">class</span>, BigInteger.<span class="hl-keyword">class</span> }));
    }

    <span class="hl-keyword">public</span> Printer&lt;Number&gt; getPrinter(NumberFormat annotation, Class&lt;?&gt; fieldType) {
        <span class="hl-keyword">return</span> configureFormatterFrom(annotation, fieldType);
    }

    <span class="hl-keyword">public</span> Parser&lt;Number&gt; getParser(NumberFormat annotation, Class&lt;?&gt; fieldType) {
        <span class="hl-keyword">return</span> configureFormatterFrom(annotation, fieldType);
    }

    <span class="hl-keyword">private</span> Formatter&lt;Number&gt; configureFormatterFrom(NumberFormat annotation,
            Class&lt;?&gt; fieldType) {
        <span class="hl-keyword">if</span> (!annotation.pattern().isEmpty()) {
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> NumberFormatter(annotation.pattern());
        } <span class="hl-keyword">else</span> {
            Style style = annotation.style();
            <span class="hl-keyword">if</span> (style == Style.PERCENT) {
                <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> PercentFormatter();
            } <span class="hl-keyword">else</span> <span class="hl-keyword">if</span> (style == Style.CURRENCY) {
                <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CurrencyFormatter();
            } <span class="hl-keyword">else</span> {
                <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> NumberFormatter();
            }
        }
    }
}</pre>
<p>To trigger formatting, simply annotate fields with @NumberFormat:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyModel {

    <em><span class="hl-annotation" style="color: gray">@NumberFormat(style=Style.CURRENCY)</span></em>
    <span class="hl-keyword">private</span> BigDecimal decimal;

}</pre>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="format-annotations-api" href="#format-annotations-api"></a>Format Annotation API</h4></div></div></div>
<p>A portable format annotation API exists in the <code class="literal">org.springframework.format.annotation</code>
package. Use @NumberFormat to format java.lang.Number fields. Use @DateTimeFormat to
format java.util.Date, java.util.Calendar, java.util.Long, or Joda Time fields.</p>
<p>The example below uses @DateTimeFormat to format a java.util.Date as a ISO Date
(yyyy-MM-dd):</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyModel {

    <em><span class="hl-annotation" style="color: gray">@DateTimeFormat(iso=ISO.DATE)</span></em>
    <span class="hl-keyword">private</span> Date date;

}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="format-FormatterRegistry-SPI" href="#format-FormatterRegistry-SPI"></a>7.6.3&nbsp;FormatterRegistry SPI</h3></div></div></div>
<p>The FormatterRegistry is an SPI for registering formatters and converters.
<code class="literal">FormattingConversionService</code> is an implementation of FormatterRegistry suitable for
most environments. This implementation may be configured programmatically or
declaratively as a Spring bean using <code class="literal">FormattingConversionServiceFactoryBean</code>. Because
this implementation also implements <code class="literal">ConversionService</code>, it can be directly configured
for use with Spring&#8217;s DataBinder and the Spring Expression Language (SpEL).</p>
<p>Review the FormatterRegistry SPI below:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.format;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> FormatterRegistry <span class="hl-keyword">extends</span> ConverterRegistry {

    <span class="hl-keyword">void</span> addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser);

    <span class="hl-keyword">void</span> addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter);

    <span class="hl-keyword">void</span> addFormatterForFieldType(Formatter&lt;?&gt; formatter);

    <span class="hl-keyword">void</span> addFormatterForAnnotation(AnnotationFormatterFactory&lt;?, ?&gt; factory);

}</pre>
<p>As shown above, Formatters can be registered by fieldType or annotation.</p>
<p>The FormatterRegistry SPI allows you to configure Formatting rules centrally, instead of
duplicating such configuration across your Controllers. For example, you might want to
enforce that all Date fields are formatted a certain way, or fields with a specific
annotation are formatted in a certain way. With a shared FormatterRegistry, you define
these rules once and they are applied whenever formatting is needed.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="format-FormatterRegistrar-SPI" href="#format-FormatterRegistrar-SPI"></a>7.6.4&nbsp;FormatterRegistrar SPI</h3></div></div></div>
<p>The FormatterRegistrar is an SPI for registering formatters and converters through the
FormatterRegistry:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.format;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> FormatterRegistrar {

    <span class="hl-keyword">void</span> registerFormatters(FormatterRegistry registry);

}</pre>
<p>A FormatterRegistrar is useful when registering multiple related converters and
formatters for a given formatting category, such as Date formatting. It can also be
useful where declarative registration is insufficient. For example when a formatter
needs to be indexed under a specific field type different from its own &lt;T&gt; or when
registering a Printer/Parser pair. The next section provides more information on
converter and formatter registration.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="format-configuring-formatting-mvc" href="#format-configuring-formatting-mvc"></a>7.6.5&nbsp;Configuring Formatting in Spring MVC</h3></div></div></div>
<p>In a Spring MVC application, you may configure a custom ConversionService instance
explicitly as an attribute of the <code class="literal">annotation-driven</code> element of the MVC namespace. This
ConversionService will then be used anytime a type conversion is required during
Controller model binding. If not configured explicitly, Spring MVC will automatically
register default formatters and converters for common types such as numbers and dates.</p>
<p>To rely on default formatting rules, no custom configuration is required in your Spring
MVC config XML:</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:mvc</span>=<span class="hl-value">"http://www.springframework.org/schema/mvc"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;mvc:annotation-driven/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>
<p>With this one-line of configuration, default formatters for Numbers and Date types will
be installed, including support for the @NumberFormat and @DateTimeFormat annotations.
Full support for the Joda Time formatting library is also installed if Joda Time is
present on the classpath.</p>
<p>To inject a ConversionService instance with custom formatters and converters registered,
set the conversion-service attribute and then specify custom converters, formatters, or
FormatterRegistrars as properties of the FormattingConversionServiceFactoryBean:</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:mvc</span>=<span class="hl-value">"http://www.springframework.org/schema/mvc"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;mvc:annotation-driven</span> <span class="hl-attribute">conversion-service</span>=<span class="hl-value">"conversionService"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"conversionService"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"converters"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;set&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.example.MyConverter"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;/set&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"formatters"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;set&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.example.MyFormatter"</span><span class="hl-tag">/&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.example.MyAnnotationFormatterFactory"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;/set&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"formatterRegistrars"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;set&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.example.MyFormatterRegistrar"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;/set&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>See <a class="xref" href="validation.html#format-FormatterRegistrar-SPI" title="7.6.4&nbsp;FormatterRegistrar SPI">Section&nbsp;7.6.4, &#8220;FormatterRegistrar SPI&#8221;</a> and the <code class="literal">FormattingConversionServiceFactoryBean</code>
for more information on when to use FormatterRegistrars.</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="format-configuring-formatting-globaldatetimeformat" href="#format-configuring-formatting-globaldatetimeformat"></a>7.7&nbsp;Configuring a global date &amp; time format</h2></div></div></div>
<p>By default, date and time fields that are not annotated with <code class="literal">@DateTimeFormat</code> are
converted from strings using the the <code class="literal">DateFormat.SHORT</code> style. If you prefer, you can
change this by defining your own global format.</p>
<p>You will need to ensure that Spring does not register default formatters, and instead
you should register all formatters manually. Use the
<code class="literal">org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</code> or
<code class="literal">org.springframework.format.datetime.DateFormatterRegistrar</code> class depending on whether
you use the Joda Time library.</p>
<p>For example, the following Java configuration will register a global ' <code class="literal">yyyyMMdd</code>'
format. This example does not depend on the Joda Time library:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AppConfig {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> FormattingConversionService conversionService() {

        <span class="hl-comment">// Use the DefaultFormattingConversionService but do not register defaults</span>
        DefaultFormattingConversionService conversionService = <span class="hl-keyword">new</span> DefaultFormattingConversionService(false);

        <span class="hl-comment">// Ensure @NumberFormat is still supported</span>
        conversionService.addFormatterForFieldAnnotation(<span class="hl-keyword">new</span> NumberFormatAnnotationFormatterFactory());

        <span class="hl-comment">// Register date conversion with a specific global format</span>
        DateFormatterRegistrar registrar = <span class="hl-keyword">new</span> DateFormatterRegistrar();
        registrar.setFormatter(<span class="hl-keyword">new</span> DateFormatter(<span class="hl-string">"yyyyMMdd"</span>));
        registrar.registerFormatters(conversionService);

        <span class="hl-keyword">return</span> conversionService;
    }
}</pre>
<p>If you prefer XML based configuration you can use a
<code class="literal">FormattingConversionServiceFactoryBean</code>. Here is the same example, this time using Joda
Time:</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&gt;

    &lt;bean id="</span><span class="hl-attribute">conversionService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"registerDefaultFormatters"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"false"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"formatters"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;set&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.format.number.NumberFormatAnnotationFormatterFactory"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;/set&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"formatterRegistrars"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;set&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"</span><span class="hl-tag">&gt;</span>
                    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dateFormatter"</span><span class="hl-tag">&gt;</span>
                        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean"</span><span class="hl-tag">&gt;</span>
                            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pattern"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"yyyyMMdd"</span><span class="hl-tag">/&gt;</span>
                        <span class="hl-tag">&lt;/bean&gt;</span>
                    <span class="hl-tag">&lt;/property&gt;</span>
                <span class="hl-tag">&lt;/bean&gt;</span>
            <span class="hl-tag">&lt;/set&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/beans&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Joda Time provides separate distinct types to represent <code class="literal">date</code>, <code class="literal">time</code> and <code class="literal">date-time</code>
values. The <code class="literal">dateFormatter</code>, <code class="literal">timeFormatter</code> and <code class="literal">dateTimeFormatter</code> properties of the
<code class="literal">JodaTimeFormatterRegistrar</code> should be used to configure the different formats for each
type. The <code class="literal">DateTimeFormatterFactoryBean</code> provides a convenient way to create formatters.</p>
</td></tr></table></div>
<p>If you are using Spring MVC remember to explicitly configure the conversion service that
is used. For Java based <code class="literal">@Configuration</code> this means extending the
<code class="literal">WebMvcConfigurationSupport</code> class and overriding the <code class="literal">mvcConversionService()</code> method.
For XML you should use the <code class="literal">'conversion-service'</code> attribute of the
<code class="literal">mvc:annotation-driven</code> element. See <a class="xref" href="validation.html#format-configuring-formatting-mvc" title="7.6.5&nbsp;Configuring Formatting in Spring MVC">Section&nbsp;7.6.5, &#8220;Configuring Formatting in Spring MVC&#8221;</a> for details.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-beanvalidation" href="#validation-beanvalidation"></a>7.8&nbsp;Spring Validation</h2></div></div></div>
<p>Spring 3 introduces several enhancements to its validation support. First, the JSR-303
Bean Validation API is now fully supported. Second, when used programmatically, Spring&#8217;s
DataBinder can now validate objects as well as bind to them. Third, Spring MVC now has
support for declaratively validating <code class="literal">@Controller</code> inputs.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="validation-beanvalidation-overview" href="#validation-beanvalidation-overview"></a>7.8.1&nbsp;Overview of the JSR-303 Bean Validation API</h3></div></div></div>
<p>JSR-303 standardizes validation constraint declaration and metadata for the Java
platform. Using this API, you annotate domain model properties with declarative
validation constraints and the runtime enforces them. There are a number of built-in
constraints you can take advantage of. You may also define your own custom constraints.</p>
<p>To illustrate, consider a simple PersonForm model with two properties:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PersonForm {
    <span class="hl-keyword">private</span> String name;
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> age;
}</pre>
<p>JSR-303 allows you to define declarative validation constraints against such properties:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PersonForm {

    <em><span class="hl-annotation" style="color: gray">@NotNull</span></em>
    <em><span class="hl-annotation" style="color: gray">@Size(max=64)</span></em>
    <span class="hl-keyword">private</span> String name;

    <em><span class="hl-annotation" style="color: gray">@Min(0)</span></em>
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> age;

}</pre>
<p>When an instance of this class is validated by a JSR-303 Validator, these constraints
will be enforced.</p>
<p>For general information on JSR-303/JSR-349, see the <a class="ulink" href="http://beanvalidation.org/" target="_top">Bean
Validation website</a>. For information on the specific capabilities of the default
reference implementation, see the <a class="ulink" href="https://www.hibernate.org/412.html" target="_top">Hibernate
Validator</a> documentation. To learn how to setup a Bean Validation provider as a Spring
bean, keep reading.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="validation-beanvalidation-spring" href="#validation-beanvalidation-spring"></a>7.8.2&nbsp;Configuring a Bean Validation Provider</h3></div></div></div>
<p>Spring provides full support for the Bean Validation API. This includes convenient
support for bootstrapping a JSR-303/JSR-349 Bean Validation provider as a Spring bean.
This allows for a <code class="literal">javax.validation.ValidatorFactory</code> or <code class="literal">javax.validation.Validator</code> to
be injected wherever validation is needed in your application.</p>
<p>Use the <code class="literal">LocalValidatorFactoryBean</code> to configure a default Validator as a Spring bean:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"validator"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"</span><span class="hl-tag">/&gt;</span></pre>
<p>The basic configuration above will trigger Bean Validation to initialize using its
default bootstrap mechanism. A JSR-303/JSR-349 provider, such as Hibernate Validator,
is expected to be present in the classpath and will be detected automatically.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="validation-beanvalidation-spring-inject" href="#validation-beanvalidation-spring-inject"></a>Injecting a Validator</h4></div></div></div>
<p><code class="literal">LocalValidatorFactoryBean</code> implements both <code class="literal">javax.validation.ValidatorFactory</code> and
<code class="literal">javax.validation.Validator</code>, as well as Spring&#8217;s
<code class="literal">org.springframework.validation.Validator</code>. You may inject a reference to either of
these interfaces into beans that need to invoke validation logic.</p>
<p>Inject a reference to <code class="literal">javax.validation.Validator</code> if you prefer to work with the Bean
Validation API directly:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> javax.validation.Validator;

<em><span class="hl-annotation" style="color: gray">@Service</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> Validator validator;</pre>
<p>Inject a reference to <code class="literal">org.springframework.validation.Validator</code> if your bean requires
the Spring Validation API:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> org.springframework.validation.Validator;

<em><span class="hl-annotation" style="color: gray">@Service</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyService {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> Validator validator;

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="validation-beanvalidation-spring-constraints" href="#validation-beanvalidation-spring-constraints"></a>Configuring Custom Constraints</h4></div></div></div>
<p>Each Bean Validation constraint consists of two parts. First, a <code class="literal">@Constraint</code> annotation
that declares the constraint and its configurable properties. Second, an implementation
of the <code class="literal">javax.validation.ConstraintValidator</code> interface that implements the constraint&#8217;s
behavior. To associate a declaration with an implementation, each <code class="literal">@Constraint</code> annotation
references a corresponding ValidationConstraint implementation class. At runtime, a
<code class="literal">ConstraintValidatorFactory</code> instantiates the referenced implementation when the
constraint annotation is encountered in your domain model.</p>
<p>By default, the <code class="literal">LocalValidatorFactoryBean</code> configures a <code class="literal">SpringConstraintValidatorFactory</code>
that uses Spring to create ConstraintValidator instances. This allows your custom
ConstraintValidators to benefit from dependency injection like any other Spring bean.</p>
<p>Shown below is an example of a custom <code class="literal">@Constraint</code> declaration, followed by an associated
<code class="literal">ConstraintValidator</code> implementation that uses Spring for dependency injection:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Target({ElementType.METHOD, ElementType.FIELD})</span></em>
<em><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></em>
<em><span class="hl-annotation" style="color: gray">@Constraint(validatedBy=MyConstraintValidator.class)</span></em>
<span class="hl-keyword">public</span> <em><span class="hl-annotation" style="color: gray">@interface</span></em> MyConstraint {
}</pre>
<pre class="programlisting"><span class="hl-keyword">import</span> javax.validation.ConstraintValidator;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyConstraintValidator <span class="hl-keyword">implements</span> ConstraintValidator {

    <em><span class="hl-annotation" style="color: gray">@Autowired;</span></em>
    <span class="hl-keyword">private</span> Foo aDependency;

    ...
}</pre>
<p>As you can see, a ConstraintValidator implementation may have its dependencies
@Autowired like any other Spring bean.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="validation-beanvalidation-spring-method" href="#validation-beanvalidation-spring-method"></a>Spring-driven Method Validation</h4></div></div></div>
<p>The method validation feature supported by Bean Validation 1.1, and as a custom
extension also by Hibernate Validator 4.3, can be integrated into a Spring context
through a <code class="literal">MethodValidationPostProcessor</code> bean definition:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.validation.beanvalidation.MethodValidationPostProcessor"</span><span class="hl-tag">/&gt;</span></pre>
<p>In order to be eligible for Spring-driven method validation, all target classes need
to be annotated with Spring&#8217;s <code class="literal">@Validated</code> annotation, optionally declaring the
validation groups to use. Check out the <code class="literal">MethodValidationPostProcessor</code> javadocs
for setup details with Hibernate Validator and Bean Validation 1.1 providers.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="validation-beanvalidation-spring-other" href="#validation-beanvalidation-spring-other"></a>Additional Configuration Options</h4></div></div></div>
<p>The default <code class="literal">LocalValidatorFactoryBean</code> configuration should prove sufficient for most
cases. There are a number of configuration options for various Bean Validation
constructs, from message interpolation to traversal resolution. See the
<code class="literal">LocalValidatorFactoryBean</code> javadocs for more information on these options.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="validation-binder" href="#validation-binder"></a>7.8.3&nbsp;Configuring a DataBinder</h3></div></div></div>
<p>Since Spring 3, a DataBinder instance can be configured with a Validator. Once
configured, the Validator may be invoked by calling <code class="literal">binder.validate()</code>. Any validation
Errors are automatically added to the binder&#8217;s BindingResult.</p>
<p>When working with the DataBinder programmatically, this can be used to invoke validation
logic after binding to a target object:</p>
<pre class="programlisting">Foo target = <span class="hl-keyword">new</span> Foo();
DataBinder binder = <span class="hl-keyword">new</span> DataBinder(target);
binder.setValidator(<span class="hl-keyword">new</span> FooValidator());

<span class="hl-comment">// bind to the target object</span>
binder.bind(propertyValues);

<span class="hl-comment">// validate the target object</span>
binder.validate();

<span class="hl-comment">// get BindingResult that includes any validation errors</span>
BindingResult results = binder.getBindingResult();</pre>
<p>A DataBinder can also be configured with multiple <code class="literal">Validator</code> instances via
<code class="literal">dataBinder.addValidators</code> and <code class="literal">dataBinder.replaceValidators</code>. This is useful when
combining globally configured Bean Validation with a Spring <code class="literal">Validator</code> configured
locally on a DataBinder instance. See <a class="xref" href="validation.html#validation-mvc-configuring" title="Configuring a Validator for use by Spring MVC">the section called &#8220;Configuring a Validator for use by Spring MVC&#8221;</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="validation-mvc" href="#validation-mvc"></a>7.8.4&nbsp;Spring MVC 3 Validation</h3></div></div></div>
<p>Beginning with Spring 3, Spring MVC has the ability to automatically validate
<code class="literal">@Controller</code> inputs. In previous versions it was up to the developer to manually invoke
validation logic.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="validation-mvc-triggering" href="#validation-mvc-triggering"></a>Triggering @Controller Input Validation</h4></div></div></div>
<p>To trigger validation of a <code class="literal">@Controller</code> input, simply annotate the input argument as
<code class="literal">@Valid</code>:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Controller</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyController {

    <em><span class="hl-annotation" style="color: gray">@RequestMapping("/foo", method=RequestMethod.POST)</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processFoo(<span class="strong"><strong>@Valid</strong></span> Foo foo) { <span class="hl-comment">/* ... */</span> }</pre>
<p>Spring MVC will validate a @Valid object after binding so-long as an appropriate
Validator has been configured.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The @Valid annotation is part of the standard JSR-303 Bean Validation API, and is not a
Spring-specific construct.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="validation-mvc-configuring" href="#validation-mvc-configuring"></a>Configuring a Validator for use by Spring MVC</h4></div></div></div>
<p>The <code class="literal">Validator</code> instance invoked when a <code class="literal">@Valid</code> method argument is encountered may be
configured in two ways. First, you may call <code class="literal">binder.setValidator(Validator)</code> within a
<code class="literal">@Controller</code>'s <code class="literal">@InitBinder</code> callback. This allows you to configure a <code class="literal">Validator</code>
instance per <code class="literal">@Controller</code> class:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Controller</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyController {

    <em><span class="hl-annotation" style="color: gray">@InitBinder</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> initBinder(WebDataBinder binder) {
        binder.setValidator(<span class="hl-keyword">new</span> FooValidator());
    }

    <em><span class="hl-annotation" style="color: gray">@RequestMapping("/foo", method=RequestMethod.POST)</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processFoo(<em><span class="hl-annotation" style="color: gray">@Valid</span></em> Foo foo) { ... }

}</pre>
<p>Second, you may call <code class="literal">setValidator(Validator)</code> on the global <code class="literal">WebBindingInitializer</code>. This
allows you to configure a <code class="literal">Validator</code> instance across all <code class="literal">@Controller</code> classes. This can be
achieved easily by using the Spring MVC namespace:</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:mvc</span>=<span class="hl-value">"http://www.springframework.org/schema/mvc"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;mvc:annotation-driven</span> <span class="hl-attribute">validator</span>=<span class="hl-value">"globalValidator"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>
<p>To combine a global and a local validator, configure the global validator as shown above
and then add a local validator:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Controller</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyController {

    <em><span class="hl-annotation" style="color: gray">@InitBinder</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> initBinder(WebDataBinder binder) {
        binder.addValidators(<span class="hl-keyword">new</span> FooValidator());
    }

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="validation-mvc-jsr303" href="#validation-mvc-jsr303"></a>Configuring a JSR-303/JSR-349 Validator for use by Spring MVC</h4></div></div></div>
<p>With Bean Validation, a single <code class="literal">javax.validation.Validator</code> instance typically validates
<span class="emphasis"><em>all</em></span> model objects that declare validation constraints. To configure such a JSR-303
backed Validator with Spring MVC, simply add a Bean Validation provider, such as
Hibernate Validator, to your classpath. Spring MVC will detect it and automatically
enable Bean Validation support across all Controllers.</p>
<p>The Spring MVC configuration required to enable Bean Validation support is shown below:</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:mvc</span>=<span class="hl-value">"http://www.springframework.org/schema/mvc"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-comment">&lt;!-- JSR-303/JSR-349 support will be detected on classpath and enabled automatically --&gt;</span>
    <span class="hl-tag">&lt;mvc:annotation-driven/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>
<p>With this minimal configuration, anytime a <code class="literal">@Valid</code> <code class="literal">@Controller</code> input is encountered, it
will be validated by the Bean Validation provider. That provider, in turn, will enforce
any constraints declared against the input. Any <code class="literal">ConstraintViolation</code>s will automatically
be exposed as errors in the <code class="literal">BindingResult</code> renderable by standard Spring MVC form tags.</p>
</div>
</div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="resources.html">이전</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-core.html">위로</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="expressions.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">6.&nbsp;리소스들&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">홈</a></td><td width="40%" align="right" valign="top">&nbsp;8.&nbsp;스프링 표현식 언어 (SpEL)</td></tr></table></div> 
</body>
</html>