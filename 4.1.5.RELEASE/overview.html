<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>2.&nbsp;스프링 프레임워크 소개</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="스프링 프레임워크 레퍼런스 문서"><link rel="up" href="spring-introduction.html" title="Part&nbsp;I.&nbsp;스프링 프레임워크의 개요"><link rel="prev" href="overview-getting-started-with-spring.html" title="1.&nbsp;스프링 시작하기"><link rel="next" href="spring-whats-new.html" title="II부.&nbsp;스프링 프레임워크 4.x에 새로운 기능"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.&nbsp;스프링 프레임워크 소개</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="overview-getting-started-with-spring.html">이전</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;I.&nbsp;스프링 프레임워크의 개요</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="spring-whats-new.html">다음</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="overview" href="#overview"></a>2.&nbsp;스프링 프레임워크 소개</h2></div></div></div>
<p>스프링 프레임워크는 자바 애플리케이션 개발을 위해 포괄적인 인프라 구조를 제공하는 자바 플랫폼이다. 스프링은 당신이 애플리케이션에 집중할 수 있도록 인프라 구조를 담당한다.</p>
<p>스프링을 사용하면 "plain old Java objects"(POJOs)로 애플리케이션을 만들고 엔터프라이즈 서비스를 비침투적으로 POJO에 적용할 수 있다. 이 능력은 Java SE 프로그래밍에 적용되고 전제 혹은 부분적으로 Java EE에 적용된다.</p>
<p>당신이 애플리케이션 개발자라고 가정할 때, 당신이 어떻게 스프링 플랫폼의 이점을 이용할 수 있는가에 대한 예제는 다음과 같다.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
트랜잭션 API를 사용하지 않고도 데이터베이스 트랜잭션에서 자바메서드를 실행하도록 만든다.
</li><li class="listitem">
원격 API를 사용하지 않고도 로컬 자바메서드를 원격 프로시저로 만든다.
</li><li class="listitem">
JMX API를 사용하지 않고도 로컬 자바메서드를 관리작업으로 만든다.
</li><li class="listitem">
JMS API를 사용하지 않고도 로컬 자바메서드를 메시지 핸들러로 만든다.
</li></ul></div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="overview-dependency-injection" href="#overview-dependency-injection"></a>2.1&nbsp;의존성 주입(DI)과 제어 역전(IoC)</h2></div></div></div>
<p>제약을 가진 임베디드 애플리케이션부터 n-티어의 서버사이드 엔터프라이즈 애플리케이션까지 전반적인 느슨하게 포함한
자바 애플리케이션은 보통 애플리케이션에 적합한 형식으로 협력하는 객체로 이루어져 있다.
그래서 애플리케이션의 객체들은 서로 <span class="emphasis"><em>의존성</em></span>을 가지고 있다.</p>
<p>자바 플랫폼이 애플리케이션 개발에 관련된 풍부한 기능을 제공하더라도,
기본적인 구성 요소들을 서로 밀착된 하나의 큰 구조로 만드는 기능은 부족하다.
따라서 아키텍트와 개발자들이 이 작업을 해야 한다.
비록, 애플리케이션을 개발시에 다양한 클래스들과 객체 인스턴스들을 구성하기 위해
<span class="emphasis"><em>팩토리</em></span>, <span class="emphasis"><em>추상 팩토리</em></span>,
<span class="emphasis"><em>빌더</em></span>, <span class="emphasis"><em>데코레이터</em></span>,
<span class="emphasis"><em>서비스 로케이터</em></span>와 같은 디자인 패턴을 사용할 수 있을 수는 있다.
하지만 이러한 패턴들은 이름이 부여된 좋은 사례들로 이런 패턴이 무슨 일을 하고, 어디에 적용할 수 있고,
어떤 문제에 대한 것인지 등을 단순히 설명한 것에 불과하다.
패턴들은 여러분의 애플리케이션에서 <span class="emphasis"><em>여러분이 스스로 구현</em></span>해야 할
공식화된 좋은 사례들인 것이다.</p>
<p>스프링 프레임워크의 <span class="emphasis"><em>제어의 역전</em></span> (IoC) 컴포넌트는 이러한 관심사에 접근한다.
즉, 서로 다른 컴포넌트들을 사용할 준비가 된 완전히 동작하는 애플리케이션을 구성하는 형식적인 의미를 제공한다.
스프링 프레임워크는 자신의 애플리케이션으로 통합할 수 있는 일급 클래스 객체들을 형식화된 디자인 패턴으로 만들었다.
수많은 단체와 기관들은 신뢰할 수 있고 <span class="emphasis"><em>유지보수 가능한</em></span> 애플리케이션을 만들려고
이러한 방법으로 스프링 프레임워크를 사용한다.</p>
<div class="sidebar"><a name="background-ioc" href="#background-ioc"></a><div class="titlepage"><div><div><p class="title"><b>배경지식</b></p></div></div></div>
<p>"<span class="emphasis"><em>제어의 어떤 관점이 역전되었는가?</em></span>" 마틴 파울러(Martin Fowler)는
2004년 <a class="ulink" href="http://martinfowler.com/articles/injection.html" target="_top">자신의 사이트</a>에서 제어의 역전(IoC)에 대한 의견을 말한적이 있다. 파울러는 원리가 더 명확하게 드러나도록 이름을 <span class="emphasis"><em>의존성 주입(Dependency Injection)</em>으로 바꾸어야 한다고 제한했다.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview-modules" href="#overview-modules"></a>2.2&nbsp;모듈</h2></div></div></div>
<p>스프링 프레임워크는 약 20개의 모듈로 구조화된 특징으로 이루어져 있다.
이러한 모듈들은 다음 다이어그램에 보이듯 핵심 컨테이너, 데이터 접근/통합, 웹, AOP(관점지향 프로그래밍),
인스트루멘테이션(Instrumentation), 메세징, 테스트로 그룹을 나눌 수 있다.</p>
<div class="figure"><a name="d5e204" href="#d5e204"></a><p class="title"><b>그림&nbsp;2.1.&nbsp;스프링 프로그램의 개요</b></p><div class="figure-contents">
<div class="mediaobject"><img src="images/spring-overview.png" alt="spring overview"></div>
</div></div><br class="figure-break">
<p>다음 섹션에서는 각각 기능별로 사용할 수 있는 모듈들의 아티팩트(artifact)명과 그것들이 다루는 주제들에 대해 나열한다.
아티팩트명들은 <a class="link" href="overview.html#dependency-management" title="2.3.1&nbsp;의존성 관리와 네이밍 컨벤션들">의존성 관리 도구들</a>에서 사용하는 <span class="emphasis"><em>아티팩트 ID들</em></span>에 대응한다.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overview-core-container" href="#overview-core-container"></a>2.2.1&nbsp;핵심 컨테이너</h3></div></div></div>
<p><a class="link" href="beans.html#beans-introduction" title="5.1&nbsp;Introduction to the Spring IoC container and beans"><span class="emphasis"><em>핵심 컨테이너</em></span></a>는 <code class="literal">spring-core</code>,
<code class="literal">spring-beans</code>, <code class="literal">spring-context</code>, <code class="literal">spring-context-support</code>, <code class="literal">spring-expression</code>(스프링 표현 언어) 모듈들로
구성되어 있다.</p>
<p><code class="literal">spring-core</code> 와 <code class="literal">spring-beans</code> 모듈은 IoC와 의존성 주입 기능들을 포함하는,
<a class="link" href="beans.html#beans-introduction" title="5.1&nbsp;Introduction to the Spring IoC container and beans">프레임워크의 근본 기능이라 할 수 있는 부분을 제공한다</a>. <code class="literal">BeanFactory</code>는 팩토리 패턴의 정교한 구현체이다.
그것은 싱글톤을 구현할 수고를 덜어주며, 실제 동작하는 프로그램 로직에서 설정과 명세를 분리하게 해준다.</p>
<p><a class="link" href="beans.html#context-introduction" title="5.15&nbsp;Additional Capabilities of the ApplicationContext"><span class="emphasis"><em>컨텍스트</em></span></a> (<code class="literal">spring-context</code>) 모듈은 <a class="link" href="beans.html#beans-introduction" title="5.1&nbsp;Introduction to the Spring IoC container and beans"><span class="emphasis"><em>핵심 및 빈즈</em></span></a> 모듈에서 제공하는 단단한 기반위에 구성되었다. 
그 말은 JNDI 레지스트리와 유사한 프레임워크-스타일로 객체에 접근한다는 의미다.
컨텐스트 모듈은 빈즈 모듈의 특징들을 상속받고 국제화(예. 리소스 번들의 사용), 이벤트 전파,
리소스 로딩, 컨텍스트의 투명한 생성(예. 서블릿 컨테이너) 같은 지원을 부가한다.
또한 컨텍스트 모듈은 EJB, JMX, 기본 리모팅 같은 Java EE의 기능을 지원한다.
<code class="literal">ApplicationContext</code> 인터페이스는 컨텍스트 모듈의 중심점을 담당한다.
<code class="literal">spring-context-support</code>는 캐싱(EhCache, Guava, JCache),
메일링(JavaMail), 스케쥴링(CommonJ, Quartz), 템플릿 엔진(FreeMarker, JasperReports, Velocity)과 같은
공통 서드-파티 라이브러리들을 스프링 애플리케이션 컨텍스트로의 통합을 지원을 제공한다.</p>
<p><code class="literal">spring-expression</code> 모듈은 런타임에서 객체 그래프를 조회하고 조작하는
강력한 <a class="link" href="expressions.html" title="8.&nbsp;Spring Expression Language (SpEL)"><span class="emphasis"><em>표현 언어</em></span></a>를 제공한다.
그것은 JSP 2.1 명세에 명시된 것처럼 통합된 표현언어(unified EL)의 확장이다.
그 언어는 프로퍼티를 설정하고 가져오는 기능과 프로퍼티 할당, 메서드 호출, 배열, 컬렉션, 인덱서의 컨텍스트 접근,
논리적 및 산술적 연산들, 이름있는 변수, 스프링의 IoC 컨테이너에서 이름으로 객체를 획득하는 기능을 지원한다.
또한 공통의 리스트 집합 뿐 아니라 리스트의 투영과 선택도 지원한다.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overview-aop-instrumentation" href="#overview-aop-instrumentation"></a>2.2.2&nbsp;AOP와 인스트루멘테이션(Instrumentation)</h3></div></div></div>
<p><code class="literal">spring-aop</code> 모듈은 <a class="link" href="aop.html#aop-introduction" title="9.1&nbsp;Introduction"><span class="emphasis"><em>AOP</em></span></a> Alliance를 따르는
관점지향 프로그래밍의 구현체다. 예를 들어 기능적으로 분리되어야 하는 코드를 깔끔하게 분리하는
메서드-인터셉터와 포인트컷을 정의할 수 있다. 소스레벨의 메타데이터 기능을 사용하면
.NET 어트리뷰트와 유사한 방법으로 행동에 관한 정보를 코드로 구현할 수 있다.</p>
<p>분리된 <code class="literal">spring-aspects</code> 모듈은 AspectJ와의 통합을 제공한다.</p>
<p><code class="literal">spring-instrument</code> 모듈은 클래스 인스트루멘테이션 지원을 제공하는
특정 애플리케이션 서버들에서 사용되는 클래스 로드 구현체들이다.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overview-messaging" href="#overview-messaging"></a>2.2.3&nbsp;메세징</h3></div></div></div>
<p>스프링 프레임워크 4는 메세징-기반의 애플리케이션들을 위한 토대를 제공하기 위해
<code class="literal">Message</code>, <code class="literal">MessageChannel</code>,
<code class="literal">MessageHandler</code> 등과 같은 <span class="emphasis"><em>스프링 통합(Spring Integration)</em></span>
프로젝트의 핵심을 추상화시킨 <code class="literal">spring-messaging</code> 모듈을 포함한다.
이 모듈은 프로그래밍 모델에 기반한 스프링 MVC 애노테이션과 유사한 메소드들에게 메시지들을 매핑하기 위한
애노테이션들의 집합도 포함한다.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overview-data-access" href="#overview-data-access"></a>2.2.4&nbsp;데이터 액세스/통합</h3></div></div></div>
<p><span class="emphasis"><em>데이터 액세스/통합</em></span> 계층은 JDBC, ORM, OXM, JMC, 트랜잭션 모듈로 이루어졌다.</p>
<p><code class="literal">spring-jdbc</code> 모듈은 <a class="link" href="jdbc.html#jdbc-introduction" title="14.1&nbsp;Introduction to Spring Framework JDBC">JDBC</a>-추상 계층을 제공한다.
그래서 지루한 JDBC 코딩과 데이터베이스 벤더에 따라 다른 오류코드를 파싱할 필요가 없다.</p>
<p><code class="literal">spring-tx</code> 모듈은 특수한 인터페이스들을 구현하기 위한 클래스들과
<span class="emphasis"><em>모든 당신의 POJO(Plain Old Java Objects)들 </em></span>을 대상으로 하는
<a class="link" href="transaction.html" title="12.&nbsp;Transaction Management">프로그램적이고 선언적인 트랜잭션</a> 관리를 지원한다.</p>
<p><code class="literal">spring-orm</code> 모듈은 <a class="link" href="orm.html#orm-jpa" title="15.5&nbsp;JPA">JPA</a>,
<a class="link" href="orm.html#orm-jdo" title="15.4&nbsp;JDO">JDO</a>, and <a class="link" href="orm.html#orm-hibernate" title="15.3&nbsp;Hibernate">Hibernate</a>를 포함하는 인기 있는
<a class="link" href="orm.html#orm-introduction" title="15.1&nbsp;Introduction to ORM with Spring">객체-관계 매핑</a> 
API에 대한 통합 계층을 제공한다. ORM 패키지를 사용하면 이러한 O/R매핑 프레임워크들을 앞에서 언급했던 선언적 트랜젝션 관리 같은 스프링의 다른 기능들과 함께 사용할 수 있다.  <code class="literal">spring-orm</code> 모듈을 사용하면
이전에 언급했던 선언적 트랜잭션 관리 기능과 같은 스프링이 제공하는 다른 기능들 모두와 조합해서
이러한 O/R 매핑 프레임워크들 모두를 사용할 수 있다.</p>
<p><code class="literal">spring-oxm</code>모듈은 JAXB, Castor, XMLBeans, JiBX and XStream와 같은 
<a class="link" href="oxm.html" title="16.&nbsp;Marshalling XML using O/X Mappers">객체/XML 매핑</a> 구현체들을
지원하는 추상 계층을 제공한다.</p>
<p><code class="literal">spring-jms</code> 모듈(<a class="link" href="jms.html" title="24.&nbsp;JMS (Java Message Service)">자바 메세징 서비스</a>)은 메세지들을 생성하고 사용하는 기능들을 포함한다.
스프링 프레임워크 4.1부터 <code class="literal">spring-messaging</code> 모듈과의 통합을 제공한다.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overview-web" href="#overview-web"></a>2.2.5&nbsp;웹</h3></div></div></div>
<p><span class="emphasis"><em>웹</em></span> 계층은 <code class="literal">spring-web</code>,
<code class="literal">spring-webmvc</code>, <code class="literal">spring-websocket</code>,
<code class="literal">spring-webmvc-portlet</code>로 이루어졌다.</p>
<p><code class="literal">spring-web</code> 모듈은 
서블릿 리스너와 웹 지향적인 애플리케이션 컨텍스트를 사용하여
멀티파트 파일 업로드 기능과  IoC 컨테이너의 초기화와 같은 기본적인 웹-지향적인 통합기능을 제공한다.
또한, HTTP 클라이언트와 스프링의 리모팅 지원의 웹-관련 부분들을 포함한다.</p>
<p><code class="literal">spring-webmvc</code> 모듈(또한 <span class="emphasis"><em>Web-Servlet</em></span> 모듈로
알려져 있는)은 웹 애플리케이션을 위한 스프링의 모델-뷰-컨트롤러(<a class="link" href="mvc.html#mvc-introduction" title="17.1&nbsp;Introduction to Spring Web MVC framework"><span class="emphasis"><em>MVC</em></span></a>)와
REST 웹 서비스들의 구현을 포함한다. 스프링의 MVC 프레임워크는 도메인 모델 코드와 웹폼 그리고 스프링 프레임워크의
다른 기능들의 모든 통합들 간의 깔끔한 분리를 제공한다.</p>
<p><code class="literal">spring-webmvc-portlet</code> 모듈(<span class="emphasis"><em>Web-Portlet</em></span> 모듈로 알려져 있는)은 Portlet 환경과 <code class="literal">spring-webmvc</code> 모듈의 기능을 사용할 수 있는
MVC 구현체을 제공한다.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overview-testing" href="#overview-testing"></a>2.2.6&nbsp;테스트</h3></div></div></div>
<p><code class="literal">spring-test</code> 모듈은 JUnit 또는 TestNG로 스프링 컴포넌트인
<a class="link" href="testing.html#unit-testing" title="11.2&nbsp;Unit Testing">단위 테스트</a>와
<a class="link" href="testing.html#integration-testing" title="11.3&nbsp;Integration Testing">통합 테스트</a>를 지원한다.
이 모듈은 스프링 <code class="literal">ApplicationContext</code>의 안정된 로딩과
이러한 컨텍스트의 <a class="link" href="testing.html#testcontext-ctx-management-caching" title="Context caching">캐싱</a>을 제공한다.
또한, 코드를 격리된 상태로 테스트하기 위해 사용할 수 있는
<a class="link" href="testing.html#mock-objects" title="11.2.1&nbsp;Mock Objects">모의 객체</a>들을 제공한다.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview-usagescenarios" href="#overview-usagescenarios"></a>2.3&nbsp;사용 시나리오들</h2></div></div></div>
<p>'제한된 리소스의 장치에서 돌아가는 임베디트 애플리케이션'부터
'스프링의 트랜잭션 관리 기능 및 웹 프레임워크 통합을 사용하는 일정 규모를 갖춘 엔터프라이즈 에플리케이션'까지
많은 시나리오 상황이 있을 수 있다.
이번 절에서는 이러한 많은 시나리오 상황에서 스프링의 논리적인 선택에 미리 도움이 되는 내용을 다룬다.</p>
<div class="figure"><a name="d5e317" href="#d5e317"></a><p class="title"><b>그림&nbsp;2.2.&nbsp;완전한 형태의 전형적인 스프링 웹 애플리케이션</b></p><div class="figure-contents">
<div class="mediaobject"><img src="images/overview-full.png" alt="overview full"></div>
</div></div><br class="figure-break">
<p>스프링의 <a class="link" href="transaction.html#transaction-declarative" title="12.5&nbsp;Declarative transaction management">선언적 트랜잭션 관리 기능</a>은
여러분이 EJB 컨테이너가 관리해주는 트랜잭션을 사용하는 것 처럼, 웹 애플리케이션이 완전한 트랙잭션 기능을 가지게 해준다.
모든 커스텀 비즈니스 로직은 간단한 POJO로 구현할 수 있고 스프링의 IoC 컨테이너로 관리할 수 있다.
또한, 부가 서비스들을 위한 지원을 포함하는데, 이메일을 보내거나  특정 지점의 유효성 확인 규칙들을 당신이 웹 계층에 독립적으로 선택하게 할 수 있는 유효성 검증 같은 서비스를 말한다.
스프링의 ORM 지원은 JPA, Hibernate, JDO, iBatis와 통합되었다. 가령 당신이 하이버네이트를 사용한다면,
이미 존재하는 매핑 파일과 표준 하이버네이트 <code class="literal">SessionFactory</code> 설정을 계속 사용할 수 있다.
폼(Form) 컨트롤러는 도메인 모델에 대한 값으로 HTTP 파라미터를 전달하는 <code class="literal">ActionForms</code>이나
다른 클래스에 대한 필요성을 제거함으로써 도메인 모델과 웹 계층을 자연스럽게 통합한다.</p>
<div class="figure"><a name="d5e328" href="#d5e328"></a><p class="title"><b>그림&nbsp;2.3.&nbsp;서드파티 웹 프레임워크(예. Struts, Tapestry)를 사용하는 스프링 미들-티어</b></p><div class="figure-contents">
<div class="mediaobject"><img src="images/overview-thirdparty-web.png" alt="overview thirdparty web"></div>
</div></div><br class="figure-break">
<p>때로는 다른 프레임워크로 완전히 전환하는 것이 어려울 수 있다.
스프링 프레임워크는 스프링 프레임워크안에서만 모든 일을 하도록 강제하지 <span class="emphasis"><em>않는다</em></span>.
즉, <span class="emphasis"><em>양자택일</em></span>을 하는 솔루션이 아니다.
이미 만들어진 프레임워크가 WebWork, Struts, Tapestry나
다른 UI 프레임워크로 만들어졌더라도 스프링의 트랜잭션 기능을 사용하는 스프링 기반의 미들-티어와 통합할 수 있다. 
Struts나 Tapestry, JSF, 다른 UI 프레임워크들로 프론트-엔트가 존재할 경우
스프링의 트랜잭션 기능을 사용하는 스프링 기반의 미들-티어와 통합할 수 있다. 
간단하게 <code class="literal">ApplicationContext</code>를 사용하는 비즈니스 로직을 연결하고 웹 계층과 통합하기 위해 <code class="literal">WebApplicationContext</code>를 사용하면 된다.</p>
<div class="figure"><a name="d5e340" href="#d5e340"></a><p class="title"><b>그림&nbsp;2.4.&nbsp;원격 사용 시나리오</b></p><div class="figure-contents">
<div class="mediaobject"><img src="images/overview-remoting.png" alt="overview remoting"></div>
</div></div><br class="figure-break">
<p>이미 존재하는 코드에 웹서비스로 접근할 필요가 있다면,
스프링의 <code class="literal">Hessian-</code>, <code class="literal">Burlap-</code>, <code class="literal">Rmi-</code>, 
<code class="literal">JaxRpcProxyFactory</code> 클래스를 사용할 수 있다.
존재하는 애플리케이션으로의 원격접근을 허용하는 것은 어렵지 않다.</p>
<div class="figure"><a name="d5e352" href="#d5e352"></a><p class="title"><b>그림&nbsp;2.5.&nbsp;EJB - 존재하는 POJO들의 랩핑(Wrapping)</b></p><div class="figure-contents">
<div class="mediaobject"><img src="images/overview-ejb.png" alt="overview ejb"></div>
</div></div><br class="figure-break">
<p>또한, 스프링 프레임워크는 엔터프라이즈 자바빈즈(Enterprise JavaBeans)를 위한
<a class="link" href="ejb.html" title="23.&nbsp;Enterprise JavaBeans (EJB) integration">액세스 및 추상화 계층</a>을 제공한다.
이러한 EJB는 기존의 POJO를 재사용 가능하게 하고, 무상태 세션빈 안에 그런 POJO들을 래핑을 하여,
선언적인 보안이 요구되는, 확장성 있고 안전장치를 갖춘 웹 애플리케이션이 된다.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dependency-management" href="#dependency-management"></a>2.3.1&nbsp;의존성 관리와 네이밍 컨벤션들</h3></div></div></div>
<p>의존성 관리과 의존성 주입은 다르다.
의존성 주입 같은 스프링의 멋진 기능들을 애플리케이션에서 사용하려면
런타임시에 필요한 모든 jar 라이브러리들을 클래스 패스에 그것들을 위치해놓아야 할 것이며,
또는 컴파일 시점에 두어야 할 필요도 있다.
이런 의존성들은 주입되는 가상 컴포넌트가 아니라 (전통적으로) 파일시스템에 존재하는 물리적 리소스이다.
의존성 관리의 프로세스는 이러한 리소스를 필요한 위치에 두고 저장하고 클래스 패스에 추가하는 작업이 포함한다.
의존성은 직접적(예. 런타임시에 스프링에 의존하는 애플리케이션)일 수도 있고
간접적(예. <code class="literal">commons-pool</code>기반의 <code class="literal">commons-dbcp</code>에 의존하는 애플리케이션)일 수도 있다.
간접적인 의존성은 보통 과도기적(transitive)이라고 부르기도 하는데, 이러한 의존성은 구별하고 관리하기가 몹시 어렵다.</p>
<p>스프링을 사용할 계획이라면 필요한 스프링 일부를 포함하는 jar 라이브러리의 복사본이 필요하다
스프링은 의존성이 최대한 분리되도록 모듈이 패키징되어 있으므로 이 작업을 쉽게 할 수 있다.
그래서 예를 들어 웹 애플리케이션을 작성할 것이 아니라면 스프링-웹 모듈은 필요 없다. 이 가이드의 스프링 라이브러리 모듈을 참조하기 위해 <code class="literal">spring-*</code>나 <code class="literal">spring-*.jar,</code>같은 짧은 작명 컨벤션을 사용한다. <code class="literal">*</code>은 모듈의 약칭을 의미한다 (예. <code class="literal">spring-core</code>,
<code class="literal">spring-webmvc</code>, <code class="literal">spring-jms</code> 등등).
실제 jar 파일명은 보통 파일명에 버전번호가 포함되어 있다
(예. <span class="emphasis"><em>spring-core-4.1.6.RELEASE.jar</em></span>).</p>
<p>각 스프링 프레임워크의 배포판은 다음 위치에 아티팩트들이 릴리즈 된다.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
메이븐 센트럴(Maven Central).
Maven Central은 Maven의 기본 저장소이므로 사용하기 위해서 특별한 설정을 할 필요는 없다.
스프링이 의존하는 공통 라이브러리 중 다수는 메이슨 센트럴에서 이용할 수 있고
스프링 커뮤니티의 많은 부분은 의존성 관리에 Maven을 사용하므로 편리하다.
Maven Central의 jar 파일명은 <code class="literal">spring-*-&lt;version&gt;.jar</code>의 형식을 따르고
Maven의 groupId는 <code class="literal">org.springframework</code>이다.
</li><li class="listitem">
퍼블릭 Maven 저장소에서 스프링은 특별하게 호스트된다.
이 저장소는 마지막 GA 릴리즈들 이외에, 개발 스냅샷들과 마일스톤들 역시 호스트된다.
jar 파일명은 Maven Central에서는 동일한 형식을 가지기 때문에,
이곳은 Maven Central에 배포된 다른 라이브러리들을 사용하기 위해
스프링의 개발 버전들을 얻기 위한 유용한 장소이다.
이 저장소는 한번에 쉽게 다운로드를 편하게 할 수 있도록,
모든 스프링의 jar파일들의 번들을 포함하는 배포용 zip 파일 형식의 번들을 포함한다.
</li></ul></div>
<p>따라서 우선 여러분의 의존성들을 어떻게 관리할지를 결정해야 한다.
우리는 보편적으로 Maven, Gradle, Ivy 같은 자동화된 시스템의 사용을 권장한다.
하지만 본인 스스로 모든 jar파일들을 다운로드 하여 수동으로 관리하는 것 역시 가능하다.</p>
<p>아래 스프링 아티팩트들의 목록이 있다. 각각의 모듈들의 세부 설명은
<a class="xref" href="overview.html#overview-modules" title="2.2&nbsp;모듈들">섹션&nbsp;2.2, &#8220;모듈&#8221;</a>에서 찾을 수 있다.</p>
<div class="table"><a name="d5e385" href="#d5e385"></a><p class="title"><b>표&nbsp;2.1.&nbsp;스프링 프레임워크의 아티팩트들(Artifacts)</b></p><div class="table-contents">
<table summary="Spring Framework Artifacts" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">GroupId</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">ArtifactId</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-aop</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>프록시-기반의 AOP 지원</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-aspects</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>AspectJ 기반의 애스팩트들</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-beans</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>그루비를 포함한 빈 지원</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-context</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>스케쥴링과 원격 추상화들을 포함하는 애플리케이션 컨텍스트 런타임</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-context-support</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>스프링 애플리케이션 컨텍스트로의 통합을 위한 공통 서드-파티 라이브러리의 클래스들의 지원
</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-core</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>다른 스프링 모듈들이 사용하는 핵심 유틸리티들</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-expression</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>스프링 표현식 언어 (SpEL)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-instrument</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>JVM 부트스트래핑을 위한 인스트루멘테이션 에이전트</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-instrument-tomcat</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>톰캣을 위한 인스트루멘테이션 에이전트</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-jdbc</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>데이터소스(DataSource) 설정과 JDBC 액세스 지원을 포함하는 JDBC 지원 패키지</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-jms</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>JMS 메세지들을 송수신을 위한 헬퍼 클래스를 포함하는 JMS 지원 패키지</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-messaging</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>메세징 아키텍쳐들과 프로토콜들을 위한 지원</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-orm</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>JPA와 하이버네이트 지원을 포함하는 객체/관계 매핑</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-oxm</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>객체/XML 매핑</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-test</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>단위 테스트와 통합 테스트를 지원을 위한 스프링 컴포넌트들</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-tx</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>DAO 지원과 JCA 통합을 포함하는 트랜잭션 인프라구조</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-web</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>클라이언트와 웹 리모팅을 포함하는 웹 지원 패키지들</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-webmvc</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>REST 웹 서비스들과 웹 애플리케이션들을 위한 모델-뷰-컨트롤러 구현</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>spring-webmvc-portlet</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Portlet 환경에서의 사용을 위한 MVC 구현</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>org.springframework</p></td><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>spring-websocket</p></td><td style="" align="left" valign="top"><p>STOMP 지원을 포함하는 웹소켓(WebSocket)과 SockJS 구현들</p></td></tr></tbody></table>
</div></div><br class="table-break">
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="overview-spring-dependencies" href="#overview-spring-dependencies"></a>스프링 의존성들과 스프링에 대한 의존</h4></div></div></div>
<p>비록 스프링이 엔터프라이즈와 다른 외부 도구들에 대한 광범위한 통합과 지원을 제공하더라도
의도적으로 의존성을 최소한으로 유지해야 한다.
간단한 사용을 위해서 (자동으로 한다고 하더라도) 많은 jar 라이브러리를 다운받아 설치하지 말아야 한다.
기본적인 의존성 주입을 사용하려면 오직 하나의 외부 의존성만 필요하고
이는 로깅을 위한 것이다(로깅 옵션에 대한 더 자세한 내용을 아래를 봐라).</p>
<p>다음은 스프링에 의존하는 애플리케이션 설정하는 필요한 기본적인 과정을 설명할 차례이다.
먼저 Maven을 살펴보고, Gradle, 그리고 Ivy를 살펴볼 것이다.
모든 경우에, 불명확한 것이 있다면, 여러분의 의존성 관리 시스템의 문서를 참고하거나, 예제코드를 보아라.
스프링은 개발과정에서 의존성 관리를 위해 그래들를 사용하고, 샘플들은 대부분 그래들이나 Maven을 사용한다.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="overview-maven-dependency-management" href="#overview-maven-dependency-management"></a>Maven 의존성 관리</h4></div></div></div>
<p><a class="ulink" href="http://maven.apache.org/" target="_top">Maven</a>으로 의존성을 관리한다면
로깅 의존성을 명시할 필요도 없다. 예를 들어 애플리케이션 컨텍스트을 생성하고
애플리케이션 설정에 의존성 주입을 사용하려면 Maven 의존성은 다음과 같을 것이다.</p>
<pre class="programlisting"><span class="hl-tag">&lt;dependencies&gt;</span>
    <span class="hl-tag">&lt;dependency&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>org.springframework<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>spring-context<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>4.1.6.RELEASE<span class="hl-tag">&lt;/version&gt;</span>
        <span class="hl-tag">&lt;scope&gt;</span>runtime<span class="hl-tag">&lt;/scope&gt;</span>
    <span class="hl-tag">&lt;/dependency&gt;</span>
<span class="hl-tag">&lt;/dependencies&gt;</span></pre>
<p>이것이 전부다. 스프링 API를 참조하여 컴파일할 필요가 없다면 scope를 runtime으로 선언할 수 있다.
이는 기본적인 의존성 주입의 유즈케이스다.</p>
<p>위의 예제에서는 Maven Central의 저장소로 동작한다. 스프링 Maven 저장소를 사용하기 위해서는
(예. 마일스톤이나 개발 스냅샷을 위해), 여러분의 Maven 설정에 저장소 경로를 지정할 필요가 있다.
전체 릴리즈를 사용하려면 다음과 같이 작성한다.</p>
<pre class="programlisting"><span class="hl-tag">&lt;repositories&gt;</span>
    <span class="hl-tag">&lt;repository&gt;</span>
        <span class="hl-tag">&lt;id&gt;</span>io.spring.repo.maven.release<span class="hl-tag">&lt;/id&gt;</span>
        <span class="hl-tag">&lt;url&gt;</span>http://repo.spring.io/release/<span class="hl-tag">&lt;/url&gt;</span>
        <span class="hl-tag">&lt;snapshots&gt;</span><span class="hl-tag">&lt;enabled&gt;</span>false<span class="hl-tag">&lt;/enabled&gt;</span><span class="hl-tag">&lt;/snapshots&gt;</span>
    <span class="hl-tag">&lt;/repository&gt;</span>
<span class="hl-tag">&lt;/repositories&gt;</span></pre>
<p>마일스톤을 사용하려면 다음과 같이 작성한다.</p>
<pre class="programlisting"><span class="hl-tag">&lt;repositories&gt;</span>
    <span class="hl-tag">&lt;repository&gt;</span>
        <span class="hl-tag">&lt;id&gt;</span>io.spring.repo.maven.milestone<span class="hl-tag">&lt;/id&gt;</span>
        <span class="hl-tag">&lt;url&gt;</span>http://repo.spring.io/milestone/<span class="hl-tag">&lt;/url&gt;</span>
        <span class="hl-tag">&lt;snapshots&gt;</span><span class="hl-tag">&lt;enabled&gt;</span>false<span class="hl-tag">&lt;/enabled&gt;</span><span class="hl-tag">&lt;/snapshots&gt;</span>
    <span class="hl-tag">&lt;/repository&gt;</span>
<span class="hl-tag">&lt;/repositories&gt;</span></pre>
<p>개발 스냅샷을 사용하려면 다음과 같이 작성한다.</p>
<pre class="programlisting"><span class="hl-tag">&lt;repositories&gt;</span>
    <span class="hl-tag">&lt;repository&gt;</span>
        <span class="hl-tag">&lt;id&gt;</span>io.spring.repo.maven.snapshot<span class="hl-tag">&lt;/id&gt;</span>
        <span class="hl-tag">&lt;url&gt;</span>http://repo.spring.io/snapshot/<span class="hl-tag">&lt;/url&gt;</span>
        <span class="hl-tag">&lt;snapshots&gt;</span><span class="hl-tag">&lt;enabled&gt;</span>true<span class="hl-tag">&lt;/enabled&gt;</span><span class="hl-tag">&lt;/snapshots&gt;</span>
    <span class="hl-tag">&lt;/repository&gt;</span>
<span class="hl-tag">&lt;/repositories&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="overview-maven-bom" href="#overview-maven-bom"></a>Maven의 "제품 구성 사양(bill of materials, BOM)" 의존성</h4></div></div></div>
<p>우연찮게 Maven을 사용하여 스프링 JAR들의 여러 버전들을 섞어서 사용할 경우가 있을 것이다.
예를 들어, 서드-파티 라이브러리나 다른 스프링 프로젝트를 찾았는데
그것들이 옛날 릴리즈를 이행적(transitive)으로 의존을 하고 있다고 하자.
혹시 의존성을 당신 스스로 명시적으로 선언하는 것을 잊어버렸다면, 예상하지 못한 이슈들이 발생할 수 있다.</p>
<p>그러한 문제들을 해결하기 위해 Maven은 "제품 구성 사항" (BOM)의 개념을 제공한다.
모든 스프링 의존성들이 동일한 버전에 있는 것을 보장(직접 혹은 이행적인 것 모두)하기 위해서
당신의 <code class="literal">dependencyManagement</code> 섹션에
<code class="literal">spring-framework-bom</code>를 추가할 수 있다.</p>
<pre class="programlisting"><span class="hl-tag">&lt;dependencyManagement&gt;</span>
    <span class="hl-tag">&lt;dependencies&gt;</span>
        <span class="hl-tag">&lt;dependency&gt;</span>
            <span class="hl-tag">&lt;groupId&gt;</span>org.springframework<span class="hl-tag">&lt;/groupId&gt;</span>
            <span class="hl-tag">&lt;artifactId&gt;</span>spring-framework-bom<span class="hl-tag">&lt;/artifactId&gt;</span>
            <span class="hl-tag">&lt;version&gt;</span>4.1.6.RELEASE<span class="hl-tag">&lt;/version&gt;</span>
            <span class="hl-tag">&lt;type&gt;</span>pom<span class="hl-tag">&lt;/type&gt;</span>
            <span class="hl-tag">&lt;scope&gt;</span>import<span class="hl-tag">&lt;/scope&gt;</span>
        <span class="hl-tag">&lt;/dependency&gt;</span>
    <span class="hl-tag">&lt;/dependencies&gt;</span>
<span class="hl-tag">&lt;/dependencyManagement&gt;</span></pre>
<p>BOM을 사용하면서 생기는 부가적인 이익은 스프링 프레임워크의 아티팩트들의 의존성을 지정시에
더이상 특정 <code class="literal">&lt;version&gt;</code> 속성을 지정할 필요가 없어졌다는 것이다.</p>
<pre class="programlisting"><span class="hl-tag">&lt;dependencies&gt;</span>
    <span class="hl-tag">&lt;dependency&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>org.springframework<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>spring-context<span class="hl-tag">&lt;/artifactId&gt;</span>
    <span class="hl-tag">&lt;/dependency&gt;</span>
    <span class="hl-tag">&lt;dependency&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>org.springframework<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>spring-web<span class="hl-tag">&lt;/artifactId&gt;</span>
    <span class="hl-tag">&lt;/dependency&gt;</span>
<span class="hl-tag">&lt;dependencies&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="overview-gradle-dependency-management" href="#overview-gradle-dependency-management"></a>Gradle 의존성 관리</h4></div></div></div>
<p>To use the Spring repository with the <a class="ulink" href="http://www.gradle.org/" target="_top">Gradle</a> build system,
include the appropriate URL in the <code class="literal">repositories</code> section:</p>
<pre class="programlisting">repositories {
    mavenCentral()
    // and optionally...
    maven { url "http://repo.spring.io/release" }
}</pre>
<p>You can change the <code class="literal">repositories</code> URL from <code class="literal">/release</code> to <code class="literal">/milestone</code> or <code class="literal">/snapshot</code> as
appropriate. Once a repository has been configured, you can declare dependencies in the
usual Gradle way:</p>
<pre class="programlisting">dependencies {
    compile("org.springframework:spring-context:4.1.6.RELEASE")
    testCompile("org.springframework:spring-test:4.1.6.RELEASE")
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="overview-ivy-dependency-management" href="#overview-ivy-dependency-management"></a>Ivy 의존성 관리</h4></div></div></div>
<p>If you prefer to use <a class="ulink" href="http://ant.apache.org/ivy" target="_top">Ivy</a> to manage dependencies then there
are similar configuration options.</p>
<p>To configure Ivy to point to the Spring repository add the following resolver to your
<code class="literal">ivysettings.xml</code>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;resolvers&gt;</span>
    <span class="hl-tag">&lt;ibiblio</span> <span class="hl-attribute">name</span>=<span class="hl-value">"io.spring.repo.maven.release"</span>
            <span class="hl-attribute">m2compatible</span>=<span class="hl-value">"true"</span>
            <span class="hl-attribute">root</span>=<span class="hl-value">"http://repo.spring.io/release/"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/resolvers&gt;</span></pre>
<p>You can change the <code class="literal">root</code> URL from <code class="literal">/release/</code> to <code class="literal">/milestone/</code> or <code class="literal">/snapshot/</code> as
appropriate.</p>
<p>Once configured, you can add dependencies in the usual way. For example (in <code class="literal">ivy.xml</code>):</p>
<pre class="programlisting"><span class="hl-tag">&lt;dependency</span> <span class="hl-attribute">org</span>=<span class="hl-value">"org.springframework"</span>
    <span class="hl-attribute">name</span>=<span class="hl-value">"spring-core"</span> <span class="hl-attribute">rev</span>=<span class="hl-value">"4.1.6.RELEASE"</span> <span class="hl-attribute">conf</span>=<span class="hl-value">"compile-&gt;runtime"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="overview-distribution-zip" href="#overview-distribution-zip"></a>Zip 파일들의 배포</h4></div></div></div>
<p>Although using a build system that supports dependency management is the recommended
way to obtain the Spring Framework, it is still possible to download a distribution
zip file.</p>
<p>Distribution zips are published to the Spring Maven Repository (this is just for our
convenience, you don&#8217;t need Maven or any other build system in order to download them).</p>
<p>To download a distribution zip open a web browser to
<a class="ulink" href="http://repo.spring.io/release/org/springframework/spring" target="_top">http://repo.spring.io/release/org/springframework/spring</a> and select the appropriate
subfolder for the version that you want. Distribution files end <code class="literal">-dist.zip</code>, for example
<code class="literal">spring-framework-4.1.6.RELEASE-RELEASE-dist.zip</code>. Distributions are also published
for <a class="ulink" href="http://repo.spring.io/milestone/org/springframework/spring" target="_top">milestones</a> and
<a class="ulink" href="http://repo.spring.io/snapshot/org/springframework/spring" target="_top">snapshots</a>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overview-logging" href="#overview-logging"></a>2.3.2&nbsp;로깅</h3></div></div></div>
<p>Logging is a very important dependency for Spring because <span class="emphasis"><em>a)</em></span> it is the only mandatory
external dependency, <span class="emphasis"><em>b)</em></span> everyone likes to see some output from the tools they are
using, and <span class="emphasis"><em>c)</em></span> Spring integrates with lots of other tools all of which have also made
a choice of logging dependency. One of the goals of an application developer is often to
have unified logging configured in a central place for the whole application, including
all external components. This is more difficult than it might have been since there are so
many choices of logging framework.</p>
<p>The mandatory logging dependency in Spring is the Jakarta Commons Logging API (JCL). We
compile against JCL and we also make JCL <code class="literal">Log</code> objects visible for classes that extend
the Spring Framework. It&#8217;s important to users that all versions of Spring use the same
logging library: migration is easy because backwards compatibility is preserved even
with applications that extend Spring. The way we do this is to make one of the modules
in Spring depend explicitly on <code class="literal">commons-logging</code> (the canonical implementation of JCL),
and then make all the other modules depend on that at compile time. If you are using
Maven for example, and wondering where you picked up the dependency on
<code class="literal">commons-logging</code>, then it is from Spring and specifically from the central module
called <code class="literal">spring-core</code>.</p>
<p>The nice thing about <code class="literal">commons-logging</code> is that you don&#8217;t need anything else to make your
application work. It has a runtime discovery algorithm that looks for other logging
frameworks in well known places on the classpath and uses one that it thinks is
appropriate (or you can tell it which one if you need to). If nothing else is available
you get pretty nice looking logs just from the JDK (java.util.logging or JUL for short).
You should find that your Spring application works and logs happily to the console out
of the box in most situations, and that&#8217;s important.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="overview-not-using-commons-logging" href="#overview-not-using-commons-logging"></a>Commons Logging 사용하지 않기</h4></div></div></div>
<p>Unfortunately, the runtime discovery algorithm in <code class="literal">commons-logging</code>, while convenient
for the end-user, is problematic. If we could turn back the clock and start Spring now
as a new project it would use a different logging dependency. The first choice would
probably be the Simple Logging Facade for Java ( <a class="ulink" href="http://www.slf4j.org" target="_top">SLF4J</a>), which is
also used by a lot of other tools that people use with Spring inside their applications.</p>
<p>There are basically two ways to switch off <code class="literal">commons-logging</code>:</p>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Exclude the dependency from the <code class="literal">spring-core</code> module (as it is the only module that
explicitly depends on <code class="literal">commons-logging</code>)
</li><li class="listitem">
Depend on a special <code class="literal">commons-logging</code> dependency that replaces the library with
an empty jar (more details can be found in the
<a class="ulink" href="http://slf4j.org/faq.html#excludingJCL" target="_top">SLF4J FAQ</a>)
</li></ol></div>
<p>To exclude commons-logging, add the following to your <code class="literal">dependencyManagement</code> section:</p>
<pre class="programlisting"><span class="hl-tag">&lt;dependencies&gt;</span>
    <span class="hl-tag">&lt;dependency&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>org.springframework<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>spring-core<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>4.1.6.RELEASE<span class="hl-tag">&lt;/version&gt;</span>
        <span class="hl-tag">&lt;exclusions&gt;</span>
            <span class="hl-tag">&lt;exclusion&gt;</span>
                <span class="hl-tag">&lt;groupId&gt;</span>commons-logging<span class="hl-tag">&lt;/groupId&gt;</span>
                <span class="hl-tag">&lt;artifactId&gt;</span>commons-logging<span class="hl-tag">&lt;/artifactId&gt;</span>
            <span class="hl-tag">&lt;/exclusion&gt;</span>
        <span class="hl-tag">&lt;/exclusions&gt;</span>
    <span class="hl-tag">&lt;/dependency&gt;</span>
<span class="hl-tag">&lt;/dependencies&gt;</span></pre>
<p>Now this application is probably broken because there is no implementation of the JCL
API on the classpath, so to fix it a new one has to be provided. In the next section we
show you how to provide an alternative implementation of JCL using SLF4J as an example.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="overview-logging-slf4j" href="#overview-logging-slf4j"></a>SLF4J 사용하기</h4></div></div></div>
<p>SLF4J is a cleaner dependency and more efficient at runtime than <code class="literal">commons-logging</code>
because it uses compile-time bindings instead of runtime discovery of the other logging
frameworks it integrates. This also means that you have to be more explicit about what
you want to happen at runtime, and declare it or configure it accordingly. SLF4J
provides bindings to many common logging frameworks, so you can usually choose one that
you already use, and bind to that for configuration and management.</p>
<p>SLF4J provides bindings to many common logging frameworks, including JCL, and it also
does the reverse: bridges between other logging frameworks and itself. So to use SLF4J
with Spring you need to replace the <code class="literal">commons-logging</code> dependency with the SLF4J-JCL
bridge. Once you have done that then logging calls from within Spring will be translated
into logging calls to the SLF4J API, so if other libraries in your application use that
API, then you have a single place to configure and manage logging.</p>
<p>A common choice might be to bridge Spring to SLF4J, and then provide explicit binding
from SLF4J to Log4J. You need to supply 4 dependencies (and exclude the existing
<code class="literal">commons-logging</code>): the bridge, the SLF4J API, the binding to Log4J, and the Log4J
implementation itself. In Maven you would do that like this</p>
<pre class="programlisting"><span class="hl-tag">&lt;dependencies&gt;</span>
    <span class="hl-tag">&lt;dependency&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>org.springframework<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>spring-core<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>4.1.6.RELEASE<span class="hl-tag">&lt;/version&gt;</span>
        <span class="hl-tag">&lt;exclusions&gt;</span>
            <span class="hl-tag">&lt;exclusion&gt;</span>
                <span class="hl-tag">&lt;groupId&gt;</span>commons-logging<span class="hl-tag">&lt;/groupId&gt;</span>
                <span class="hl-tag">&lt;artifactId&gt;</span>commons-logging<span class="hl-tag">&lt;/artifactId&gt;</span>
            <span class="hl-tag">&lt;/exclusion&gt;</span>
        <span class="hl-tag">&lt;/exclusions&gt;</span>
    <span class="hl-tag">&lt;/dependency&gt;</span>
    <span class="hl-tag">&lt;dependency&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>org.slf4j<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>jcl-over-slf4j<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>1.5.8<span class="hl-tag">&lt;/version&gt;</span>
    <span class="hl-tag">&lt;/dependency&gt;</span>
    <span class="hl-tag">&lt;dependency&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>org.slf4j<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>slf4j-api<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>1.5.8<span class="hl-tag">&lt;/version&gt;</span>
    <span class="hl-tag">&lt;/dependency&gt;</span>
    <span class="hl-tag">&lt;dependency&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>org.slf4j<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>slf4j-log4j12<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>1.5.8<span class="hl-tag">&lt;/version&gt;</span>
    <span class="hl-tag">&lt;/dependency&gt;</span>
    <span class="hl-tag">&lt;dependency&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>log4j<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>log4j<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>1.2.14<span class="hl-tag">&lt;/version&gt;</span>
    <span class="hl-tag">&lt;/dependency&gt;</span>
<span class="hl-tag">&lt;/dependencies&gt;</span></pre>
<p>That might seem like a lot of dependencies just to get some logging. Well it is, but it
<span class="emphasis"><em>is</em></span> optional, and it should behave better than the vanilla <code class="literal">commons-logging</code> with
respect to classloader issues, notably if you are in a strict container like an OSGi
platform. Allegedly there is also a performance benefit because the bindings are at
compile-time not runtime.</p>
<p>A more common choice amongst SLF4J users, which uses fewer steps and generates fewer
dependencies, is to bind directly to <a class="ulink" href="http://logback.qos.ch" target="_top">Logback</a>. This removes the
extra binding step because Logback implements SLF4J directly, so you only need to depend
on two libraries not four ( <code class="literal">jcl-over-slf4j</code> and <code class="literal">logback</code>). If you do that you might
also need to exclude the slf4j-api dependency from other external dependencies (not
Spring), because you only want one version of that API on the classpath.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="overview-logging-log4j" href="#overview-logging-log4j"></a>Log4J 사용하기</h4></div></div></div>
<p>Many people use <a class="ulink" href="http://logging.apache.org/log4j" target="_top">Log4j</a> as a logging framework for
configuration and management purposes. It&#8217;s efficient and well-established, and in fact
it&#8217;s what we use at runtime when we build and test Spring. Spring also provides some
utilities for configuring and initializing Log4j, so it has an optional compile-time
dependency on Log4j in some modules.</p>
<p>To make Log4j work with the default JCL dependency ( <code class="literal">commons-logging</code>) all you need to
do is put Log4j on the classpath, and provide it with a configuration file (
<code class="literal">log4j.properties</code> or <code class="literal">log4j.xml</code> in the root of the classpath). So for Maven users this
is your dependency declaration:</p>
<pre class="programlisting"><span class="hl-tag">&lt;dependencies&gt;</span>
    <span class="hl-tag">&lt;dependency&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>org.springframework<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>spring-core<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>4.1.6.RELEASE<span class="hl-tag">&lt;/version&gt;</span>
    <span class="hl-tag">&lt;/dependency&gt;</span>
    <span class="hl-tag">&lt;dependency&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>log4j<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>log4j<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>1.2.14<span class="hl-tag">&lt;/version&gt;</span>
    <span class="hl-tag">&lt;/dependency&gt;</span>
<span class="hl-tag">&lt;/dependencies&gt;</span></pre>
<p>And here&#8217;s a sample log4j.properties for logging to the console:</p>
<pre class="literallayout">log4j.rootCategory=INFO, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %t %c{2}:%L - %m%n

log4j.category.org.springframework.beans.factory=DEBUG</pre>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="overview-native-jcl" href="#overview-native-jcl"></a>네이티브 JCL 런타임 컨테이너 사용하기</h5></div></div></div>
<p>Many people run their Spring applications in a container that itself provides an
implementation of JCL. IBM Websphere Application Server (WAS) is the archetype. This
often causes problems, and unfortunately there is no silver bullet solution; simply
excluding <code class="literal">commons-logging</code> from your application is not enough in most situations.</p>
<p>To be clear about this: the problems reported are usually not with JCL per se, or even
with <code class="literal">commons-logging</code>: rather they are to do with binding <code class="literal">commons-logging</code> to another
framework (often Log4J). This can fail because <code class="literal">commons-logging</code> changed the way they do
the runtime discovery in between the older versions (1.0) found in some containers and
the modern versions that most people use now (1.1). Spring does not use any unusual
parts of the JCL API, so nothing breaks there, but as soon as Spring or your application
tries to do any logging you can find that the bindings to Log4J are not working.</p>
<p>In such cases with WAS the easiest thing to do is to invert the class loader hierarchy
(IBM calls it "parent last") so that the application controls the JCL dependency, not
the container. That option isn&#8217;t always open, but there are plenty of other suggestions
in the public domain for alternative approaches, and your mileage may vary depending on
the exact version and feature set of the container.</p>
</div>
</div>
</div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="overview-getting-started-with-spring.html">이전</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-introduction.html">위로</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="spring-whats-new.html">다음</a></td></tr><tr><td width="40%" align="left" valign="top">1.&nbsp;스프링 시작하기&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">홈</a></td><td width="40%" align="right" valign="top">&nbsp;II부.&nbsp;스프링 프레임워크 4.x에 새로운 기능</td></tr></table></div> 
</body>
</html>